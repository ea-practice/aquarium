<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Risk Aquarium Visualization</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <!-- Add SheetJS library for Excel parsing -->
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <style>
      /* All existing styles remain unchanged */
      :root {
        --priority-1-color: #3b82f6; /* Blue */
        --priority-2-color: #10b981; /* Green */
        --priority-3-color: #facc15; /* Yellow */
        --priority-4-color: #f97316; /* Orange */
        --priority-5-color: #ef4444; /* Red */

        --velocity-1-color: #93c5fd; /* Light blue */
        --velocity-2-color: #60a5fa; /* Medium blue */
        --velocity-3-color: #2563eb; /* Dark blue */
      }

      body {
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      .dark {
        background-color: #181818;
        color: #ffffff;
      }

      .light {
        background-color: #ffffff;
        color: #181818;
      }

      .aquarium {
        background: linear-gradient(
          to bottom,
          rgba(173, 216, 230, 0.2),
          rgba(0, 0, 128, 0.4)
        );
        border: 2px solid #5d5cde;
        border-radius: 8px;
        overflow: hidden;
        position: relative;
      }

      .aquarium::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(
            circle at 10% 20%,
            rgba(255, 255, 255, 0.03) 0%,
            rgba(255, 255, 255, 0) 20%
          ),
          radial-gradient(
            circle at 80% 30%,
            rgba(255, 255, 255, 0.03) 0%,
            rgba(255, 255, 255, 0) 20%
          );
        pointer-events: none;
      }

      /* Add safe zone for zero-risk entities */
      .safe-zone {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 15%;
        background: rgba(50, 205, 50, 0.05);
        border-top: 1px dashed rgba(50, 205, 50, 0.3);
        pointer-events: none;
        z-index: 2;
      }

      .safe-zone::before {
        content: "Safe Zone (No Risks)";
        position: absolute;
        left: 10px;
        top: 2px;
        font-size: 10px;
        color: rgba(50, 205, 50, 0.7);
      }

      .risk-bubble {
        position: absolute;
        transform-origin: center;
        transition: all 0.5s ease-in-out;
        cursor: pointer;
        filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.3));
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background: radial-gradient(
          circle at 30% 30%,
          rgba(255, 255, 255, 0.5),
          rgba(255, 255, 255, 0.1)
        );
        z-index: 5; /* Base z-index for all bubbles */
      }

      /* Style for entities with zero risks */
      .no-risks {
        opacity: 0.4;
        border: 1px dashed #888;
      }

      /* Highlight effect for hovered bubbles */
      .risk-bubble:hover {
        z-index: 50; /* Higher z-index when hovered */
        filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.5));
        transform: scale(1.05);
      }

      .fish-id {
        position: relative;
        z-index: 2;
        font-weight: bold;
        color: white;
        text-shadow: 0 0 3px black;
        font-size: 10px;
        text-align: center;
        pointer-events: none;
      }

      .time-slider-container {
        width: calc(100% - 80px);
        margin-left: 70px;
        padding: 10px 0;
      }

      .org-slider-container {
        position: relative;
        width: 70px;
        margin-right: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 10px;
        z-index: 10;
        border-radius: 8px 0 0 8px;
      }

      .horizontal-slider {
        width: 100%;
        appearance: none;
        height: 8px;
        background: #d3d3d3;
        outline: none;
        border-radius: 4px;
      }

      .vertical-slider {
        appearance: none;
        width: 20px;
        height: 80%;
        background: #d3d3d3;
        outline: none;
        border-radius: 4px;
        writing-mode: bt-lr; /* Vertical orientation */
        -webkit-appearance: slider-vertical;
        transform: rotate(180deg); /* Fixes the reversal issue */
      }

      .dark .org-slider-container {
        background-color: rgba(40, 40, 50, 0.7);
        border-color: #444;
      }

      .horizontal-slider::-webkit-slider-thumb,
      .vertical-slider::-webkit-slider-thumb {
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #5d5cde;
        cursor: pointer;
      }

      .horizontal-slider::-moz-range-thumb,
      .vertical-slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #5d5cde;
        cursor: pointer;
      }

      .vertical-slider-labels {
        position: absolute;
        right: 3px;
        height: 80%;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        font-size: 0.75rem;
        padding: 5px 0;
      }

      .vertical-slider-labels span {
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
        transition: background-color 0.2s;
      }

      .vertical-slider-labels span:hover {
        background-color: rgba(93, 92, 222, 0.1);
      }

      .popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border: 2px solid #5d5cde;
        border-radius: 8px;
        padding: 20px;
        max-width: 600px;
        width: 90%;
        z-index: 1000;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      }

      .popup-content {
        max-height: 80vh;
        overflow-y: auto;
      }

      .dark .popup {
        background-color: #2d2d2d;
        color: white;
      }

      .backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 999;
      }

      .tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 100;
        pointer-events: none;
        white-space: nowrap;
        transform: translate(-50%, -100%);
        top: -10px;
        opacity: 0;
        transition: opacity 0.2s;
      }

      .bubbles {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }

      .bubble {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        animation: bubble-rise linear infinite;
      }

      @keyframes bubble-rise {
        0% {
          transform: translateY(0) translateX(0);
          opacity: 0.7;
        }
        100% {
          transform: translateY(-100vh) translateX(20px);
          opacity: 0;
        }
      }

      .org-level-label {
        position: absolute;
        right: 10px;
        font-weight: bold;
        background-color: rgba(93, 92, 222, 0.1);
        padding: 5px 10px;
        border-radius: 4px;
        border-left: 4px solid #5d5cde;
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .fish-id {
          font-size: 8px;
        }

        .controls-container {
          flex-direction: column;
        }
      }

      /* Legend sizing */
      .legend-container {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 0.25rem;
        font-size: 0.75rem;
        width: calc(100% - 80px);
        margin-left: 70px;
        margin-top: 0.5rem;
      }

      .legend-item {
        padding: 0.25rem 0.5rem;
        border: 1px solid #ddd;
        border-radius: 0.25rem;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      }

      .legend-title {
        font-weight: 600;
        margin-bottom: 0.25rem;
        font-size: 0.7rem;
      }

      .legend-entry {
        display: flex;
        align-items: center;
        margin-bottom: 0.125rem;
      }

      .legend-color {
        width: 0.6rem;
        height: 0.6rem;
        border-radius: 9999px;
        margin-right: 0.375rem;
      }

      /* Dark mode toggle */
      .theme-toggle {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        cursor: pointer;
        background: none;
        border: none;
        color: inherit;
        font-size: 1.2rem;
      }

      /* Risk details popup */
      .risk-metrics {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 15px;
      }

      .metric-card {
        flex: 1;
        min-width: 120px;
        padding: 10px;
        border-radius: 6px;
        border: 1px solid #ddd;
        text-align: center;
      }

      .dark .metric-card {
        border-color: #444;
      }

      .metric-value {
        font-size: 1.5rem;
        font-weight: bold;
        margin: 5px 0;
      }

      .metric-label {
        font-size: 0.8rem;
        color: #666;
      }

      .dark .metric-label {
        color: #aaa;
      }

      .trend-container {
        height: 150px; /* Fixed height for chart */
        margin-top: 10px;
      }

      /* Loading indicator */
      .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
        color: white;
        font-size: 1.2rem;
      }

      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top: 4px solid white;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .data-status {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 0.8rem;
        z-index: 10;
      }

      /* Debug overlay for development */
      .debug-overlay {
        position: absolute;
        top: 40px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 4px;
        font-size: 0.75rem;
        z-index: 100;
        max-width: 300px;
        max-height: 200px;
        overflow: auto;
      }
    </style>
  </head>
  <body class="min-h-screen p-4 transition-colors">
    <button class="theme-toggle" aria-label="Toggle dark/light mode">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-6 w-6 theme-icon-dark hidden"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
        />
      </svg>
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-6 w-6 theme-icon-light"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
        />
      </svg>
    </button>

    <div class="max-w-7xl mx-auto">
      <h1 class="text-3xl font-bold mb-4 text-center">Risk Aquarium</h1>

      <div class="mb-4 relative flex">
        <div class="org-slider-container">
          <input
            type="range"
            min="0"
            max="4"
            value="0"
            class="vertical-slider"
            id="org-slider"
          />
          <div class="vertical-slider-labels">
            <span id="label-org" onclick="setOrgLevel(0)">Org</span>
            <span id="label-div" onclick="setOrgLevel(1)">Div</span>
            <span id="label-dept" onclick="setOrgLevel(2)">Dept</span>
            <span id="label-bu" onclick="setOrgLevel(3)">BU</span>
            <span id="label-risks" onclick="setOrgLevel(4)">Risks</span>
          </div>
        </div>
        <div
          class="aquarium flex-grow"
          id="aquarium"
          style="height: 60vh; width: calc(100% - 80px)"
        >
          <div class="safe-zone" id="safe-zone"></div>
          <div class="bubbles" id="bubbles"></div>
          <div id="org-level-indicator" class="org-level-label">
            Organization
          </div>
          <div id="data-status" class="data-status"></div>
          <div
            id="debug-overlay"
            class="debug-overlay"
            style="display: none"
          ></div>
        </div>
      </div>

      <div class="mt-2 controls-container">
        <div class="time-slider-container">
          <label for="time-slider" class="block mb-2 font-medium"
            >Time: <span id="time-label">Current</span></label
          >
          <input
            type="range"
            min="0"
            max="4"
            value="4"
            class="horizontal-slider"
            id="time-slider"
          />
          <div class="flex justify-between text-xs mt-1">
            <span>4 weeks ago</span>
            <span>3 weeks ago</span>
            <span>2 weeks ago</span>
            <span>1 week ago</span>
            <span>Current</span>
          </div>
        </div>
      </div>

      <div class="legend-container">
        <div class="legend-item">
          <div class="legend-title">Priority Legend</div>
          <!-- Reordered to match aquarium - high priority at top, low at bottom -->
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--priority-5-color)"
            ></div>
            <span>P5 - High</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--priority-4-color)"
            ></div>
            <span>P4</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--priority-3-color)"
            ></div>
            <span>P3</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--priority-2-color)"
            ></div>
            <span>P2</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--priority-1-color)"
            ></div>
            <span>P1 - Low</span>
          </div>
        </div>

        <div class="legend-item">
          <div class="legend-title">Velocity Legend</div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--velocity-3-color)"
            ></div>
            <span>V3 - Fast</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--velocity-2-color)"
            ></div>
            <span>V2</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--velocity-1-color)"
            ></div>
            <span>V1 - Slow</span>
          </div>
        </div>

        <div class="legend-item">
          <div class="legend-title">Size Legend</div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="width: 0.9rem; height: 0.9rem; border: 1px solid #ccc"
            ></div>
            <span>Large - High Impact</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="width: 0.7rem; height: 0.7rem; border: 1px solid #ccc"
            ></div>
            <span>Medium</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="width: 0.5rem; height: 0.5rem; border: 1px solid #ccc"
            ></div>
            <span>Small - Low Impact</span>
          </div>
          <div class="legend-entry mt-2">
            <div
              class="legend-color opacity-40"
              style="width: 0.7rem; height: 0.7rem; border: 1px dashed #888"
            ></div>
            <span>No Risks</span>
          </div>
        </div>
      </div>

      <div class="mt-4 text-center">
        <button
          id="toggle-debug"
          class="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded text-sm hover:bg-gray-300 dark:hover:bg-gray-600"
        >
          Toggle Debug Info
        </button>
      </div>

      <!-- Add file upload for cases where direct file access doesn't work -->
      <div class="mt-4 mx-auto text-center">
        <h3 class="text-lg font-bold mb-2">Manual File Upload</h3>
        <p class="text-sm mb-2">
          If automatic loading fails, upload week files here:
        </p>
        <input
          type="file"
          id="file-input"
          accept=".xlsx"
          multiple
          class="mb-2"
        />
        <div id="file-list" class="text-sm"></div>
      </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <script>
      // CONFIGURABLE CONSTANTS - SIMPLIFIED
      const CONFIG = {
        // Keep only the DEBUG flag, remove unused constants
        DEBUG: true,
      };

      // Time-indexed data storage - store separate datasets for each time period
      const timeIndexedData = {
        0: null, // 4 weeks ago
        1: null, // 3 weeks ago
        2: null, // 2 weeks ago
        3: null, // 1 week ago
        4: null, // Current
      };

      // File mapping in reverse order to match logical time flow
      const weekFiles = [
        "week_04.xlsx",
        "week_03.xlsx",
        "week_02.xlsx",
        "week_01.xlsx",
        "week_00.xlsx",
      ];

      // Current active data (will point to one of the timeIndexedData entries)
      let data = null;
      let currentLoadedTimeIndex = null;

      // Track selected entities for drill-down
      let selectedDivision = null;
      let selectedDepartment = null;
      let selectedBU = null;

      // Add a pre-filtering function for future risk filtering feature
      let activeRiskFilters = null; // Will be populated when filtering is added

      // Debug logging - keep intact for upcoming filtering feature
      function debugLog(message, data = null) {
        if (!CONFIG.DEBUG) return;

        try {
          const debugOverlay = document.getElementById("debug-overlay");
          if (!debugOverlay) return; // Safety check

          const timestamp = new Date().toLocaleTimeString();
          let logMessage = `<div class="mb-1"><span class="opacity-50">${timestamp}</span> ${message}</div>`;

          if (data) {
            try {
              // For objects, stringify them
              if (typeof data === "object") {
                const stringified = JSON.stringify(data, null, 2)
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;");
                logMessage += `<pre class="text-xs bg-black bg-opacity-50 p-1 my-1 rounded overflow-auto max-h-20">${stringified}</pre>`;
              } else {
                logMessage += `<pre class="text-xs bg-black bg-opacity-50 p-1 my-1 rounded">${data}</pre>`;
              }
            } catch (e) {
              logMessage += `<div class="text-red-300">[Error displaying data: ${e.message}]</div>`;
            }
          }

          debugOverlay.innerHTML = logMessage + debugOverlay.innerHTML;

          // Limit the amount of debug messages to prevent browser slowdown
          if (debugOverlay.children.length > 20) {
            debugOverlay.lastChild.remove();
          }

          // Also log to console
          console.log(message, data);
        } catch (error) {
          // Fail silently - debug logging should never break the application
          console.log("Debug log error:", error);
        }
      }

      // Theme detection and toggle
      const prefersDarkScheme = window.matchMedia(
        "(prefers-color-scheme: dark)"
      );
      const body = document.body;
      const themeToggle = document.querySelector(".theme-toggle");
      const darkIcon = document.querySelector(".theme-icon-dark");
      const lightIcon = document.querySelector(".theme-icon-light");

      function setTheme(isDark) {
        if (isDark) {
          body.classList.add("dark");
          body.classList.remove("light");
          darkIcon.classList.remove("hidden");
          lightIcon.classList.add("hidden");
        } else {
          body.classList.add("light");
          body.classList.remove("dark");
          darkIcon.classList.add("hidden");
          lightIcon.classList.remove("hidden");
        }
      }

      // Set initial theme based on system preference
      setTheme(prefersDarkScheme.matches);

      // Toggle theme when button is clicked
      themeToggle.addEventListener("click", () => {
        const isDark = body.classList.contains("dark");
        setTheme(!isDark);
      });

      // Update theme if system preference changes
      prefersDarkScheme.addEventListener("change", (e) => {
        setTheme(e.matches);
      });

      // Toggle debug overlay
      document.getElementById("toggle-debug").addEventListener("click", () => {
        const debugOverlay = document.getElementById("debug-overlay");
        debugOverlay.style.display =
          debugOverlay.style.display === "none" ? "block" : "none";
      });

      // Add file upload handler for manual loading
      const fileInput = document.getElementById("file-input");
      const fileList = document.getElementById("file-list");
      const uploadedFiles = {};

      fileInput.addEventListener("change", function (e) {
        const files = e.target.files;
        fileList.innerHTML = "";

        Array.from(files).forEach((file) => {
          const reader = new FileReader();
          reader.onload = function (event) {
            try {
              const data = new Uint8Array(event.target.result);
              const workbook = XLSX.read(data, { type: "array" });

              // Store workbook by filename
              uploadedFiles[file.name] = workbook;
              fileList.innerHTML += `<div>${file.name} - Loaded successfully</div>`;

              // Process the workbook and store it in timeIndexedData
              const match = file.name.match(/week_(\d+)\.xlsx/i);
              if (match) {
                const weekNum = parseInt(match[1]);
                const timeIndex = weekNum === 0 ? 4 : 4 - weekNum; // Map week 00 to index 4
                const processedData = processExcelWorkbook(workbook);
                timeIndexedData[timeIndex] = processedData;
                debugLog(
                  `Stored processed data for time index ${timeIndex} (${file.name})`
                );
              }
            } catch (error) {
              fileList.innerHTML += `<div class="text-red-500">${file.name} - Error: ${error.message}</div>`;
              console.error(
                `Error processing uploaded file ${file.name}:`,
                error
              );
            }
          };
          reader.readAsArrayBuffer(file);
        });
      });

      // Add common animation function to reduce code duplication
      function addFloatingAnimation(element) {
        element.animate(
          [
            { transform: "translate(0, 0) scale(1)" },
            {
              transform: `translate(${
                Math.random() > 0.5 ? 5 : -5
              }px, -5px) scale(1.03)`,
            },
            { transform: "translate(0, 0) scale(1)" },
          ],
          {
            duration: 3000 + Math.random() * 2000,
            iterations: Infinity,
            easing: "ease-in-out",
          }
        );
      } // eof addFloatingAnimation

      // Utility Functions (Lines 600â€“650)
      function parseSheet(sheet) {
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 }); // Get rows as a 2D array
        const headers = rows[0].map((header) => header.trim()); // Normalize headers
        const data = rows.slice(1).map((row) =>
          headers.reduce((acc, header, index) => {
            acc[header] = row[index]; // Map each column to its header
            return acc;
          }, {})
        );
        return data; // Return an array of objects
      } // eof parseSheet

      // Parsing functionality
      /*
        function parseFile(workbook) 
        {
            const sheets = workbook.Sheets;

            // Determine file format based on the presence of specific fields
            // const isNewFormat = sheets["Org Structure"] && sheets["Org Structure"][0].ID;
            // console.info(`Read sheet Org Structure :`);

            var orgSheet = sheets["Org Structure"]; // raw orgSheet object
            const orgStructure = parseOrgStructure(parseSheet(orgSheet));
            console.info(`Org Structure :`, orgStructure);

            // rawSheet = sheets["Risks"]; // raw riskSheet object
            // console.info("Risks sheet", rawSheet);
            const risks = parseRisks(parseSheet(sheets["Risks"]), orgStructure);

            // rawSheet = sheets["Assets"]; // raw riskSheet object
            // console.info("Assets sheet", rawSheet);
            const assets = parseAssets(parseSheet(sheets["Assets"]), orgStructure);

            console.info("Parsed risks:", risks);
            console.info("Parsed assets:", assets);

            return { orgStructure, risks, assets };
        } // end of parseFile
        */

      // build Org Structure
      function buildHierarchy(orgStructure) {
        const root = Object.values(orgStructure).find(
          (unit) => unit.Level === 1
        ); // Find the root (organization)
        if (!root) {
          throw new Error("No root organization found in the org structure!");
        }
        return root; // Return the root node of the hierarchy tree
      } // end of buildHierarchy

      function parseOrgStructure(sheet) {
        console.log("parseOrgStructure: Starting org structure parsing...");
        console.log("parseOrgStructure: Raw sheet data:", sheet);

        if (!sheet) {
          console.error(
            "parseOrgStructure: Organizational Structure sheet is missing!"
          );
          return {};
        }

        // Convert sheet to JSON, reading rows as raw arrays
        const rows = XLSX.utils.sheet_to_json(sheet, {
          defval: null,
          header: 1, // Read as raw rows
        });

        console.log("parseOrgStructure: Raw rows from sheet:", rows);

        // **DYNAMIC HEADER ROW DETECTION**
        let headerRowIndex = -1;
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          if (
            row.includes("ID") &&
            row.includes("Parent_ID") &&
            row.includes("Name")
          ) {
            headerRowIndex = i;
            break;
          }
        }

        if (headerRowIndex === -1) {
          console.error(
            "parseOrgStructure: Could not find a valid header row!"
          );
          return {};
        }

        const headers = rows[headerRowIndex];
        console.log("parseOrgStructure: Extracted headers:", headers);

        // **HEADER VALIDATION AND NORMALIZATION**
        if (!headers || headers.length === 0) {
          console.error("parseOrgStructure: Header row is empty or invalid!");
          return {};
        }

        const normalizedHeaders = headers.map((header) => {
          if (typeof header === "string") {
            return header.trim().toLowerCase();
          } else {
            console.warn("parseOrgStructure: Skipping invalid header:", header);
            return null;
          }
        });

        console.log(
          "parseOrgStructure: Normalized headers:",
          normalizedHeaders
        );

        const idIndex = normalizedHeaders.indexOf("id");
        const parentIdIndex = normalizedHeaders.indexOf("parent_id");
        const nameIndex = normalizedHeaders.indexOf("name");
        const levelIndex = normalizedHeaders.indexOf("level");

        if (idIndex === -1 || parentIdIndex === -1 || nameIndex === -1) {
          console.error(
            "parseOrgStructure: Missing required columns (ID, Parent_ID, Name) in sheet headers!"
          );
          return {};
        }

        const orgStructure = {};

        // **PROCESS DATA ROWS**
        rows.slice(headerRowIndex + 1).forEach((row) => {
          const id = row[idIndex] ? String(row[idIndex]).trim() : null;
          const parentId = row[parentIdIndex]
            ? String(row[parentIdIndex]).trim()
            : null;
          const name = row[nameIndex] ? String(row[nameIndex]).trim() : null;
          const level = row[levelIndex]
            ? parseInt(row[levelIndex], 10) || 0
            : 0;

          if (!id) {
            console.warn(
              "parseOrgStructure: Skipping row with missing ID:",
              row
            );
            return;
          }

          orgStructure[id] = {
            id,
            level,
            name,
            parentId,
            children: [],
          };

          // console.log(`parseOrgStructure: Added org unit with ID=${id}, Parent_ID=${parentId}`);
        });

        // **LINK CHILDREN TO PARENTS**
        Object.keys(orgStructure).forEach((id) => {
          const unit = orgStructure[id];
          if (unit.parentId && orgStructure[unit.parentId]) {
            orgStructure[unit.parentId].children.push(unit);
          }
        });

        console.log("parseOrgStructure: Parsed orgStructure:", orgStructure);

        // **VERIFY ROOT NODE**
        if (!orgStructure["1"] || !orgStructure["1"].name) {
          console.error(
            "parseOrgStructure: Root node (ID=1) is undefined or missing a Name!"
          );
        } else {
          console.log("parseOrgStructure: Root node:", orgStructure["1"]);
        }

        return orgStructure;
      } // eof parseOrgStructure

      function parseRisks(sheet, orgStructure) {
        console.log("parseRisks: Starting risk parsing...");

        if (!sheet) {
          console.error("parseRisks: Risks sheet is missing!");
          return [];
        }

        // Convert the sheet into rows
        const rows = XLSX.utils.sheet_to_json(sheet, {
          defval: null,
          header: 1, // Read as raw rows
        });

        console.log("parseRisks: Raw rows from sheet:", rows);

        // Extract and validate headers
        const headers = rows[0];
        if (!headers || headers.length === 0) {
          console.error("parseRisks: Header row is empty or missing!");
          return [];
        }

        // Normalize headers
        const normalizedHeaders = headers.map((header) => {
          if (typeof header === "string") {
            return header.trim().toLowerCase();
          } else {
            console.warn("parseRisks: Skipping invalid header:", header);
            return null;
          }
        });

        // Map column names to their indexes
        const orgUnitIdIndex = normalizedHeaders.indexOf("org_unit_id");
        const riskIdIndex = normalizedHeaders.indexOf("risk_id");
        const titleIndex = normalizedHeaders.indexOf("title");
        const descriptionIndex = normalizedHeaders.indexOf("description");
        const typeIndex = normalizedHeaders.indexOf("type");
        const categoryIndex = normalizedHeaders.indexOf("category");
        const ownerIndex = normalizedHeaders.indexOf("owner");
        const levelIndex = normalizedHeaders.indexOf("level");
        const priorityIndex = normalizedHeaders.indexOf("priority");
        const velocityIndex = normalizedHeaders.indexOf("velocity");
        const magnitudeIndex = normalizedHeaders.indexOf("magnitude");
        const assetIdIndex = normalizedHeaders.indexOf("asset_id");
        const mitigationPlanIndex =
          normalizedHeaders.indexOf("mitigation_plan");

        // Validate required columns
        if (orgUnitIdIndex === -1 || riskIdIndex === -1 || titleIndex === -1) {
          console.error(
            "parseRisks: Missing required columns in sheet headers!"
          );
          return [];
        }

        const risks = []; // Final risks array

        // Process each row (skip the header row)
        rows.slice(1).forEach((row) => {
          const orgUnitId = row[orgUnitIdIndex];
          if (!orgUnitId || !orgStructure[orgUnitId]) {
            console.warn(
              "parseRisks: Skipping row with missing or invalid Org_Unit_ID:",
              row
            );
            return;
          }

          // Extract all relevant fields
          const riskId = row[riskIdIndex];
          const title = row[titleIndex];
          const description =
            descriptionIndex !== -1 ? row[descriptionIndex] || "" : "";
          const type = typeIndex !== -1 ? row[typeIndex] || "" : "";
          const category = categoryIndex !== -1 ? row[categoryIndex] || "" : "";
          const owner = ownerIndex !== -1 ? row[ownerIndex] || "" : "";
          const level = levelIndex !== -1 ? row[levelIndex] || "" : "";
          const priority = priorityIndex !== -1 ? row[priorityIndex] || "" : "";
          const velocity = velocityIndex !== -1 ? row[velocityIndex] || "" : "";
          const magnitude =
            magnitudeIndex !== -1 ? row[magnitudeIndex] || "" : "";
          const assetId = assetIdIndex !== -1 ? row[assetIdIndex] || "" : "";
          const mitigationPlan =
            mitigationPlanIndex !== -1 ? row[mitigationPlanIndex] || "" : "";

          // Construct the risk object
          const risk = {
            riskId,
            title,
            description,
            type,
            category,
            owner,
            level,
            priority,
            velocity,
            magnitude,
            assetId,
            mitigationPlan,
            orgUnitId: String(orgUnitId),
          };

          console.log(
            `parseRisks: Assigning risk ${risk.riskId} to Org Unit ID ${orgUnitId}`
          );
          // Add the risk to the array
          risks.push(risk);
        });

        console.log("parseRisks: Final risks array:", risks);
        return risks;
      } // end of parseRisks

      function parseAssets(sheet, orgStructure) {
        const assets = [];
        console.info("Assets sheet: ", sheet);

        sheet.forEach((row) => {
          try {
            // Extract orgUnitId and normalize it
            const orgUnitId = row["__EMPTY_1"]
              ? String(row["__EMPTY_1"]).trim()
              : null;
            console.info("Assets: extracted orgUnitId:", orgUnitId);

            // Check if orgUnitId is valid and matches orgStructure
            if (!orgUnitId) {
              console.warn("Assets: missing orgUnitId in asset row:", row);
              return; // Skip this row
            }

            const orgUnit = orgStructure[orgUnitId];
            if (!orgUnit) {
              console.warn(
                `Assets: no matching orgUnit found for orgUnitId: ${orgUnitId}`
              );
              return; // Skip this row
            }

            console.info("Assets: matching orgUnit in orgStructure:", orgUnit);

            const asset = {
              id: row["Table 1"],
              name: row["__EMPTY"],
              value: row["__EMPTY_2"],
              orgUnit: orgUnit,
            };

            assets.push(asset);
          } catch (error) {
            console.error("Assets: error parsing row:", row, error);
          }
        });

        return assets;
      } // eof parseAssets

      // aggregate risks
      function aggregateRisks(orgHierarchy, risks) {
        const aggregated = {};

        // Recursively process the hierarchy
        function processUnit(unit) {
          const risksForUnit = risks.filter(
            (risk) => risk.orgUnit && risk.orgUnit.id === unit.id
          );

          // Aggregate risk data for this unit
          const aggregation = {
            totalMagnitude: risksForUnit.reduce(
              (sum, risk) => sum + risk.magnitude,
              0
            ),
            highestPriority: Math.max(
              0,
              ...risksForUnit.map((risk) => risk.priority)
            ),
            fastestVelocity: Math.max(
              0,
              ...risksForUnit.map((risk) => risk.velocity)
            ),
          };

          // Recurse through children
          unit.children.forEach((child) => {
            const childAggregation = processUnit(child);
            aggregation.totalMagnitude += childAggregation.totalMagnitude;
            aggregation.highestPriority = Math.max(
              aggregation.highestPriority,
              childAggregation.highestPriority
            );
            aggregation.fastestVelocity = Math.max(
              aggregation.fastestVelocity,
              childAggregation.fastestVelocity
            );
          });

          aggregated[unit.id] = aggregation;
          return aggregation;
        }

        processUnit(orgHierarchy); // Start from the root of the hierarchy
        return aggregated;
      } // end of aggregateRisks

      // Assets with Org Units association
      function associateAssetsWithOrgUnits(orgHierarchy, assets) {
        const assetsByUnit = {};

        assets.forEach((asset) => {
          const unitId = asset.orgUnit?.id;
          if (unitId) {
            if (!assetsByUnit[unitId]) {
              assetsByUnit[unitId] = [];
            }
            assetsByUnit[unitId].push(asset);
          }
        });

        return assetsByUnit;
      } // end of associateAssetsWithOrgUnits

      function updateVisualization(
        orgHierarchy,
        riskAggregations,
        assetsByOrgUnit
      ) {
        // Example: Log data for debugging
        console.log("Organizational Hierarchy:", orgHierarchy);
        console.log("Risk Aggregations:", riskAggregations);
        console.log("Assets by Org Unit:", assetsByOrgUnit);

        // TODO: Replace this with your actual visualization update logic
        // For example:
        // renderOrgHierarchy(orgHierarchy);
        // renderRiskData(riskAggregations);
        // renderAssetData(assetsByOrgUnit);
      } // end of updateVisualization

      // Parsed data processing
      function processParsedData(parsedData) {
        const { orgStructure, risks, assets } = parsedData;

        // Step 1: Build organizational hierarchy tree
        const orgHierarchy = buildHierarchy(orgStructure);

        // Step 2: Aggregate risks by organizational units
        const riskAggregations = aggregateRisks(orgHierarchy, risks);

        // Step 3: Associate assets with organizational units
        const assetsByOrgUnit = associateAssetsWithOrgUnits(
          orgHierarchy,
          assets
        );

        // Step 4: Pass processed data to the visualization
        updateVisualization(orgHierarchy, riskAggregations, assetsByOrgUnit);

        // Optionally return processed data for debugging/testing
        return { orgHierarchy, riskAggregations, assetsByOrgUnit };
      } // end of processParsedData

      async function loadExcelFile(timeIndex) {
        const filename = weekFiles[timeIndex]; // File corresponding to the current timeIndex
        const dataStatus = document.getElementById("data-status");

        try {
          // Check if the file has already been uploaded
          if (uploadedFiles[filename]) {
            debugLog(
              `Using uploaded file ${filename} for time index ${timeIndex}`
            );
            dataStatus.textContent = `Data loaded from uploaded: ${filename}`;
            return uploadedFiles[filename];
          }

          // Check if data for this time index is already processed
          if (timeIndexedData[timeIndex]) {
            debugLog(`Using cached data for time index ${timeIndex}`);
            dataStatus.textContent = `Using cached data for time period ${
              timeLabel?.textContent || timeIndex
            }`;
            return null; // File does not need to be reloaded or reprocessed
          }

          // Show loading state
          showLoading(true);
          dataStatus.textContent = `Loading data from ${filename}...`;

          // Fetch the file using the Fetch API
          const response = await fetch(`./data/${filename}`);
          if (!response.ok) {
            throw new Error(
              `Failed to fetch file: HTTP status ${response.status}`
            );
          }

          // Read the response as an ArrayBuffer
          const arrayBuffer = await response.arrayBuffer();

          // Parse the file using SheetJS (XLSX library)
          const data = new Uint8Array(arrayBuffer);
          const workbook = XLSX.read(data, { type: "array" });

          // Update status
          dataStatus.textContent = `Data loaded from ${filename}`;
          debugLog(`Successfully loaded workbook for time index ${timeIndex}`);

          return workbook;
        } catch (error) {
          // Handle errors gracefully and inform the user
          console.error(
            `Error loading Excel file for time index ${timeIndex}:`,
            error
          );
          if (dataStatus) {
            dataStatus.textContent = `Error loading data for ${filename}: ${error.message}`;
          }

          // Return null to indicate the file could not be processed
          return null;
        } finally {
          // Hide the loading indicator
          showLoading(false);
        }
      } // end of loadExcelFile

      // Process Excel workbook data and convert to our data format
      /*
        function processExcelWorkbook(workbook) 
        {
            const dataStatus = document.getElementById('data-status');
            const processedData = {
                risks: [],
                assets: [],
                orgStructure: {
                    organization: "Global Enterprise",
                    divisions: []
                }
            };

            // Parse assets sheet
            if (workbook.SheetNames.includes('Assets')) 
            {
                try {
                    const assetsSheet = workbook.Sheets['Assets'];
                    const assets = XLSX.utils.sheet_to_json(assetsSheet, { range: 3 });
                    processedData.assets = assets;
                    console.log("processExcelWorkbook: Raw assets data:", assets);
                } catch (error) {
                    console.error("processExcelWorkbook: Error parsing Assets sheet:", error);
                }
            }

            // Debug Organizational Structure sheet
            if (workbook.SheetNames.includes('Org Structure')) 
            {
                try {
                    const orgSheet = workbook.Sheets['Org Structure'];
                    const rawOrgData = XLSX.utils.sheet_to_json(orgSheet, { range: 1 });
                    console.log("processExcelWorkbook: Raw Organizational Structure data:", rawOrgData);
                    processedData.orgStructure = parseOrgStructure(rawOrgData);
                } catch (error) {
                    console.error("processExcelWorkbook: Error parsing Organizational Structure sheet:", error);
                }
            }

            // Debug Risks sheet
            if (workbook.SheetNames.includes('Risks')) 
            {
                try {
                    const risksSheet = workbook.Sheets['Risks'];
                    const rawRisksData = XLSX.utils.sheet_to_json(risksSheet, { range: 1 });
                    console.log("processExcelWorkbook: Raw Risks data:", rawRisksData);
                    processedData.risks = parseRisks(rawRisksData, processedData.orgStructure);
                } catch (error) {
                    console.error("processExcelWorkbook: Error parsing Risks sheet:", error);
                }
            }

            return processedData;
        }
        */

      function processExcelWorkbook(workbook) {
        console.log("processExcelWorkbook: Starting workbook processing...");

        // Retrieve all sheet names dynamically
        const sheetNames = workbook.SheetNames;
        console.log("processExcelWorkbook: Available sheet names:", sheetNames);

        // Initialize placeholders for the sheets we need
        let assetSheet = null;
        let orgSheet = null;
        let risksSheet = null;

        // Match sheet names dynamically
        sheetNames.forEach((sheetName) => {
          const lowerName = sheetName.toLowerCase().trim(); // Normalize for comparison

          if (lowerName.includes("asset")) {
            assetSheet = workbook.Sheets[sheetName];
            console.log(
              `processExcelWorkbook: Found Asset sheet: ${sheetName}`
            );
          } else if (
            lowerName.includes("org structure") ||
            lowerName.includes("organization")
          ) {
            orgSheet = workbook.Sheets[sheetName];
            console.log(
              `processExcelWorkbook: Found Org Structure sheet: ${sheetName}`
            );
          } else if (lowerName.includes("risk")) {
            risksSheet = workbook.Sheets[sheetName];
            console.log(
              `processExcelWorkbook: Found Risks sheet: ${sheetName}`
            );
          }
        });

        // Check if all required sheets were found
        if (!assetSheet) {
          console.error("processExcelWorkbook: Asset sheet not found!");
        }
        if (!orgSheet) {
          console.error("processExcelWorkbook: Org Structure sheet not found!");
        }
        if (!risksSheet) {
          console.error("processExcelWorkbook: Risks sheet not found!");
        }

        // If any sheet is missing, stop further processing
        if (!assetSheet || !orgSheet || !risksSheet) {
          console.error(
            "processExcelWorkbook: One or more required sheets are missing. Stopping processing."
          );
          return;
        }

        // Parse assets data
        const assetsData = XLSX.utils.sheet_to_json(assetSheet, {
          defval: null,
        });
        console.log("processExcelWorkbook: Raw assets data:", assetsData);

        // Parse organization structure
        const orgStructure = parseOrgStructure(orgSheet);
        console.log(
          "processExcelWorkbook: Parsed Organizational Structure:",
          orgStructure
        );

        // Parse risks data
        const risksData = XLSX.utils.sheet_to_json(risksSheet, {
          defval: null,
        });
        console.log("processExcelWorkbook: Raw Risks data:", risksData);

        const risks = parseRisks(risksSheet, orgStructure);
        console.log("processExcelWorkbook: Parsed Risks:", risks);

        // Return the processed data
        return {
          assets: assetsData,
          orgStructure,
          risks,
        };
      }

      // Helper function to show/hide loading indicator
      function showLoading(isLoading) {
        try {
          let loadingOverlay = document.querySelector(".loading-overlay");

          if (isLoading) {
            if (!loadingOverlay) {
              loadingOverlay = document.createElement("div");
              loadingOverlay.className = "loading-overlay";

              const spinner = document.createElement("div");
              spinner.className = "spinner";

              const text = document.createElement("div");
              text.textContent = "Loading data...";

              loadingOverlay.appendChild(spinner);
              loadingOverlay.appendChild(text);

              const aquarium = document.getElementById("aquarium");
              if (aquarium) {
                aquarium.appendChild(loadingOverlay);
              }
            }
          } else if (loadingOverlay) {
            loadingOverlay.remove();
          }
        } catch (error) {
          console.error("Error toggling loading indicator:", error);
          // Fail silently - loading indicator should never break the application
        }
      }

      // Initialize UI elements with safety checks
      const aquarium = document.getElementById("aquarium");
      const tooltip = document.getElementById("tooltip");
      const timeSlider = document.getElementById("time-slider");
      const timeLabel = document.getElementById("time-label");
      const orgSlider = document.getElementById("org-slider");
      const orgLevelIndicator = document.getElementById("org-level-indicator");
      const bubblesContainer = document.getElementById("bubbles");
      const safeZone = document.getElementById("safe-zone");

      /* Add utility function to get risk attributes - useful for future filtering
      function getRiskAttributes(risk, timeIndex) {
        if (!risk) return null;

        try {
          const timeData = risk.timeData?.[timeIndex] || {
            priority: 3,
            velocity: 2,
            magnitude: 3,
          };

          const processedRisk = {
            id: risk.id,
            title: risk.title,
            level: risk.level,
            category: risk.category,
            entity: risk.entity,
            parentEntity: risk.parentEntity,
            grandparentEntity: risk.grandparentEntity,
            owner: risk.owner,
            priority: timeData.priority,
            velocity: timeData.velocity,
            magnitude: timeData.magnitude,
            assetId: risk.assetId,
            assetName: risk.assetName,
            assetOwner: risk.assetOwner,
          };

          console.log("Processed risk:", processedRisk);
          return processedRisk;
        } catch (error) {
          debugLog("Error getting risk attributes:", error);
          return null;
        }
      } */

      // Utility function to check if a risk is related to a BU
      function isBURisk(risk, buName, departmentName) {
        if (!risk || !buName || !departmentName) return false;
        if (risk.level !== "bu") return false;
        if (risk.entity !== departmentName) return false;

        return (
          risk.title?.includes(buName) ||
          (risk.description && risk.description.includes(buName))
        );
      }

      /* Function for future risk filtering - prepare for upcoming feature
      function filterRisks(risks, filterCriteria) {
        if (!risks || !Array.isArray(risks)) return [];
        if (!filterCriteria) return risks;

        return risks.filter((risk) => {
          for (const [key, value] of Object.entries(filterCriteria)) {
            // Skip undefined criteria
            if (value === undefined) continue;

            // Special case for numeric ranges
            if (
              key === "priorityRange" &&
              value.min !== undefined &&
              value.max !== undefined
            ) {
              const priority = getRiskAttributes(
                risk,
                currentLoadedTimeIndex
              )?.priority;
              if (priority < value.min || priority > value.max) return false;
              continue;
            }

            // Special case for text search
            if (key === "textSearch" && value) {
              const searchText = value.toLowerCase();
              const matchesSearch =
                risk.id?.toLowerCase().includes(searchText) ||
                risk.title?.toLowerCase().includes(searchText) ||
                risk.description?.toLowerCase().includes(searchText);
              if (!matchesSearch) return false;
              continue;
            }

            // Regular property matching
            const riskValue = risk[key];
            if (riskValue !== value) return false;
          }

          return true;
        });
      }
      */

      // Function to group risks by attributes - preparation for upcoming feature
      function groupRisksByAttribute(risks, attribute) {
        if (!risks || !Array.isArray(risks)) return {};

        const groups = {};

        risks.forEach((risk) => {
          const attrValue = risk[attribute] || "Unknown";
          if (!groups[attrValue]) {
            groups[attrValue] = [];
          }
          groups[attrValue].push(risk);
        });

        return groups;
      }

      // Switch to the data for a specific time index
      function switchToTimeIndex(timeIndex) {
        try {
          if (timeIndexedData[timeIndex]) {
            data = timeIndexedData[timeIndex];
            currentLoadedTimeIndex = timeIndex;

            debugLog("switchToTimeIndex: Data Risks are ", data.risks);

            // Update time label
            if (timeLabel) {
              switch (timeIndex) {
                case 0:
                  timeLabel.textContent = "4 weeks ago";
                  break;
                case 1:
                  timeLabel.textContent = "3 weeks ago";
                  break;
                case 2:
                  timeLabel.textContent = "2 weeks ago";
                  break;
                case 3:
                  timeLabel.textContent = "1 week ago";
                  break;
                case 4:
                  timeLabel.textContent = "Current";
                  break;
                default:
                  timeLabel.textContent = `Time ${timeIndex}`;
              }
            }

            // Update status
            const dataStatus = document.getElementById("data-status");
            if (dataStatus) {
              dataStatus.textContent = `Showing data for ${
                timeLabel?.textContent || timeIndex
              } (${weekFiles[timeIndex] || "unknown"})`;
            }

            debugLog("Switched to time index", timeIndex);

            return true;
          }
          return false;
        } catch (error) {
          debugLog("Error switching time index:", error);
          return false;
        }
      }

      // Get color based on priority
      function getPriorityColor(priority) {
        try {
          switch (Math.round(priority || 3)) {
            case 1:
              return "var(--priority-1-color)";
            case 2:
              return "var(--priority-2-color)";
            case 3:
              return "var(--priority-3-color)";
            case 4:
              return "var(--priority-4-color)";
            case 5:
              return "var(--priority-5-color)";
            default:
              return "var(--priority-3-color)";
          }
        } catch (error) {
          debugLog("Error getting priority color:", error);
          return "var(--priority-3-color)"; // Default fallback
        }
      }

      // Create risk bubble element
      function createRiskBubbleElement(risk, timeIndex) {
        try {
          if (!risk) {
            debugLog("Warning: Attempted to create bubble for undefined risk");
            return null;
          }

          const timeData = risk.timeData?.[timeIndex] || {
            priority: 3,
            velocity: 2,
            magnitude: 3,
          };

          const priority = timeData.priority;
          const velocity = timeData.velocity;
          const magnitude = timeData.magnitude;

          const bubbleElement = document.createElement("div");
          bubbleElement.classList.add("risk-bubble");
          bubbleElement.dataset.id = risk.id;

          // Set size based on magnitude (1-5)
          const baseSize = 40; // base size in pixels
          const size = baseSize + (magnitude - 1) * 15; // scale size based on magnitude
          bubbleElement.style.width = `${size}px`;
          bubbleElement.style.height = `${size}px`;

          // Set position based on priority (vertical) and velocity (horizontal)
          // Higher priority bubbles should be higher in the aquarium
          // Higher velocity bubbles should be more to the right

          // Create vertical position based on priority (5 = highest, 1 = lowest)
          // Add some randomness to prevent exact alignment
          const verticalPosition =
            85 - ((priority - 1) * 15 + Math.random() * 5);
          bubbleElement.style.top = `${verticalPosition}%`;

          // Create horizontal position based on velocity (3 = rightmost, 1 = leftmost)
          // Add some randomness to prevent exact alignment
          const horizontalPosition = (velocity - 1) * 30 + Math.random() * 10;
          bubbleElement.style.left = `${horizontalPosition}%`;

          // Set color based on priority
          const color = getPriorityColor(priority);
          bubbleElement.style.backgroundColor = color;

          // Add risk ID
          const riskId = document.createElement("div");
          riskId.classList.add("fish-id"); // Keeping the class name for simplicity
          riskId.textContent = risk.id;
          bubbleElement.appendChild(riskId);

          // Add floating animation (consolidated into a shared function)
          addFloatingAnimation(bubbleElement);

          // Add tooltip on hover
          bubbleElement.addEventListener("mouseenter", (e) => {
            if (!tooltip) return;

            tooltip.innerHTML = `
                        <strong>${risk.id}</strong><br>
                        Magnitude: ${magnitude.toFixed(1)}<br>
                        Priority: P${Math.round(priority)}<br>
                        Velocity: V${Math.round(velocity)}<br>
                        Asset: ${risk.assetName || "N/A"}
                    `;

            const rect = bubbleElement.getBoundingClientRect();
            tooltip.style.left = `${rect.left + rect.width / 2}px`;
            tooltip.style.top = `${rect.top}px`;
            tooltip.style.opacity = "1";
          });

          bubbleElement.addEventListener("mouseleave", () => {
            if (!tooltip) return;
            tooltip.style.opacity = "0";
          });

          // Add click to show details popup
          bubbleElement.addEventListener("click", () => {
            showRiskDetails(risk, timeIndex);
          });

          return bubbleElement;
        } catch (error) {
          debugLog("Error creating risk bubble:", error);
          return null;
        }
      }

      // Create decorative bubbles
      function createBubbles() {
        try {
          if (!bubblesContainer) return;

          bubblesContainer.innerHTML = "";
          const bubbleCount = 15;

          for (let i = 0; i < bubbleCount; i++) {
            const bubble = document.createElement("div");
            bubble.classList.add("bubble");

            // Random size between 5px and 20px
            const size = 5 + Math.random() * 15;
            bubble.style.width = `${size}px`;
            bubble.style.height = `${size}px`;

            // Random horizontal position
            const left = Math.random() * 100;
            bubble.style.left = `${left}%`;

            // Random start position vertically (some below the viewport)
            const bottom = -20 + Math.random() * 100;
            bubble.style.bottom = `${bottom}%`;

            // Random animation duration between 10s and 30s
            const duration = 10 + Math.random() * 20;
            bubble.style.animationDuration = `${duration}s`;

            // Random delay so they don't all start at the same time
            const delay = Math.random() * 15;
            bubble.style.animationDelay = `${delay}s`;

            bubblesContainer.appendChild(bubble);
          }
        } catch (error) {
          debugLog("Error creating decorative bubbles:", error);
          // Continue without decorative bubbles
        }
      }

      // Show risk details in popup
      function showRiskDetails(risk, timeIndex) {
        try {
          if (!risk) {
            debugLog("Warning: Attempted to show details for undefined risk");
            return;
          }

          // Remove existing popup if any
          const existingPopup = document.querySelector(".popup");
          const existingBackdrop = document.querySelector(".backdrop");

          if (existingPopup) {
            existingPopup.remove();
          }

          if (existingBackdrop) {
            existingBackdrop.remove();
          }

          // Create backdrop
          const backdrop = document.createElement("div");
          backdrop.classList.add("backdrop");
          document.body.appendChild(backdrop);

          // Create popup
          const popup = document.createElement("div");
          popup.classList.add("popup");

          const timeData = risk.timeData?.[timeIndex] || {
            priority: 3,
            velocity: 2,
            magnitude: 3,
          };

          const priority = timeData.priority;
          const velocity = timeData.velocity;
          const magnitude = timeData.magnitude;

          // Create popup content - revised for better visibility and includes asset information
          popup.innerHTML = `
                    <div class="popup-content">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-xl font-bold">${risk.id}: ${
            risk.title
          }</h2>
                            <button class="close-popup text-gray-500 hover:text-gray-700">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                        
                        <div>
                            <p class="mb-2"><strong>Description:</strong> ${
                              risk.description || "No description provided"
                            }</p>
                            <p class="mb-2"><strong>Category:</strong> ${
                              risk.category || "Uncategorized"
                            }</p>
                            <p class="mb-2"><strong>Owner:</strong> ${
                              risk.owner || "Unassigned"
                            }</p>
                            <p class="mb-2"><strong>Organization Level:</strong> ${
                              risk.level || "Unknown"
                            } (${risk.entity || "Unknown entity"})</p>
                            <p class="mb-2"><strong>Affected Asset:</strong> ${
                              risk.assetName || "N/A"
                            }</p>
                            <p class="mb-2"><strong>Asset Owner:</strong> ${
                              risk.assetOwner || "N/A"
                            }</p>
                            <p class="mb-2"><strong>Asset Value:</strong> ${
                              risk.assetValue
                                ? "$" + risk.assetValue.toLocaleString()
                                : "N/A"
                            }</p>
                            <p class="mb-2"><strong>Mitigation Plan:</strong> ${
                              risk.mitigationPlan ||
                              "No mitigation plan provided"
                            }</p>
                        </div>
                        
                        <!-- Metrics display without scrolling -->
                        <div class="risk-metrics mt-4">
                            <div class="metric-card" style="border-left: 4px solid ${getPriorityColor(
                              priority
                            )};">
                                <div class="metric-label">Priority</div>
                                <div class="metric-value">P${Math.round(
                                  priority
                                )}</div>
                                <div class="metric-label">${
                                  [
                                    "Very Low",
                                    "Low",
                                    "Medium",
                                    "High",
                                    "Very High",
                                  ][Math.round(priority) - 1] || "Medium"
                                }</div>
                            </div>
                            
                            <div class="metric-card" style="border-left: 4px solid var(--velocity-${Math.round(
                              velocity
                            )}-color);">
                                <div class="metric-label">Velocity</div>
                                <div class="metric-value">V${Math.round(
                                  velocity
                                )}</div>
                                <div class="metric-label">${
                                  ["Slow", "Medium", "Fast"][
                                    Math.round(velocity) - 1
                                  ] || "Medium"
                                }</div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-label">Magnitude</div>
                                <div class="metric-value">${magnitude.toFixed(
                                  1
                                )}</div>
                                <div class="metric-label">${
                                  [
                                    "Very Low",
                                    "Low",
                                    "Medium",
                                    "High",
                                    "Very High",
                                  ][Math.round(magnitude) - 1] || "Medium"
                                }</div>
                            </div>
                        </div>
                        
                        <div class="mt-4">
                            <h3 class="font-medium mb-2">Historical Trend</h3>
                            <div class="trend-container">
                                <canvas id="trendChart"></canvas>
                            </div>
                        </div>
                    </div>
                `;

          document.body.appendChild(popup);

          // Close popup when clicking the close button
          const closeButton = popup.querySelector(".close-popup");
          if (closeButton) {
            closeButton.addEventListener("click", () => {
              popup.remove();
              backdrop.remove();
            });
          }

          // Close popup when clicking backdrop
          backdrop.addEventListener("click", () => {
            popup.remove();
            backdrop.remove();
          });

          // Close popup when pressing Escape key
          document.addEventListener("keydown", function closeOnEscape(e) {
            if (e.key === "Escape") {
              popup.remove();
              backdrop.remove();
              document.removeEventListener("keydown", closeOnEscape);
            }
          });

          // Create trend chart with fixed height
          const ctx = document.getElementById("trendChart")?.getContext("2d");
          if (ctx) {
            try {
              new Chart(ctx, {
                type: "line",
                data: {
                  labels: [
                    "4 weeks ago",
                    "3 weeks ago",
                    "2 weeks ago",
                    "1 week ago",
                    "Current",
                  ],
                  datasets: [
                    {
                      label: "Priority",
                      data: risk.timeData?.map((d) => d?.priority) || [
                        3, 3, 3, 3, 3,
                      ],
                      borderColor: "rgb(255, 99, 132)",
                      backgroundColor: "rgba(255, 99, 132, 0.2)",
                      fill: false,
                      tension: 0.1,
                    },
                    {
                      label: "Velocity",
                      data: risk.timeData?.map((d) => d?.velocity) || [
                        2, 2, 2, 2, 2,
                      ],
                      borderColor: "rgb(54, 162, 235)",
                      backgroundColor: "rgba(54, 162, 235, 0.2)",
                      fill: false,
                      tension: 0.1,
                    },
                    {
                      label: "Magnitude",
                      data: risk.timeData?.map((d) => d?.magnitude) || [
                        3, 3, 3, 3, 3,
                      ],
                      borderColor: "rgb(255, 159, 64)",
                      backgroundColor: "rgba(255, 159, 64, 0.2)",
                      fill: false,
                      tension: 0.1,
                    },
                  ],
                },
                options: {
                  scales: {
                    y: {
                      beginAtZero: false,
                      min: 1,
                      max: 5,
                      ticks: {
                        stepSize: 1,
                      },
                    },
                  },
                  responsive: true,
                  maintainAspectRatio: false,
                },
              });
            } catch (chartError) {
              debugLog("Error creating trend chart:", chartError);
              // Continue without chart
            }
          }
        } catch (error) {
          debugLog("Error showing risk details:", error);
          // If we can't show the popup, at least log the error
        }
      }

      function calculateAggregatedRiskMetrics(
        entityType,
        entityName,
        parentEntityName,
        timeIndex
      ) {
        try {
          // Debug inputs
          console.log(
            `calculating: Calculating metrics for ${entityType}: ${entityName}, time index: ${timeIndex}`
          );

          // Validate risks data
          if (!data.risks || data.risks.length === 0) {
            console.warn(
              `calculating: No risks available for entity ${entityType}: ${entityName}`
            );
            return defaultMetrics();
          }

          // Debug full risk data
          console.log(`calculating: Full risk data:`, data.risks);

          // Find the organizational unit ID for the current entity
          const orgUnit = findOrgUnitByName(entityName, parentEntityName);
          if (!orgUnit) {
            console.warn(
              `calculating: No organizational unit found for entity ${entityName}`
            );
            return defaultMetrics();
          }

          // Debug organizational unit
          console.log(
            `calculating: Found org unit for ${entityName}:`,
            orgUnit
          );

          // Filter risks based on the orgUnitId of the current entity
          const entityRisks = data.risks.filter(
            (risk) => risk.orgUnitId === String(orgUnit.id)
          );

          // Debug filtered risks
          console.log(
            `calculating: Risk count for ${entityName}: ${entityRisks.length}`,
            entityRisks
          );

          // Handle cases where no risks are associated with the entity
          if (entityRisks.length === 0) {
            console.warn(
              `calculating: No risks found for entity ${entityType}: ${entityName}`
            );
            return defaultMetrics();
          }

          // Calculate metrics based on filtered risks
          const metrics = calculateMetricsFromRisks(entityRisks);

          // Debug calculated metrics
          console.log(
            `calculating: Calculated metrics for ${entityName}:`,
            metrics
          );

          return metrics;
        } catch (error) {
          // Robust error handling
          console.error(
            `calculating: Error calculating metrics for ${entityType}: ${entityName}`,
            error
          );
          return defaultMetrics();
        }
      }

      const currentData = {};

      function findOrgUnitByName(entityName, parentEntityName) {
        // Validate the organizational structure data
        if (!currentData || !currentData.orgStructure) {
          console.warn(
            "findOrgUnitByName: Organization structure is undefined."
          );
          return null;
        }

        // If no parentEntityName is provided, search the root or top-level units
        if (!parentEntityName) {
          return Object.values(currentData.orgStructure).find(
            (orgUnit) => orgUnit.name === entityName
          );
        }

        // If a parentEntityName is provided, search within the parent's children
        const parentOrgUnit = Object.values(currentData.orgStructure).find(
          (orgUnit) => orgUnit.name === parentEntityName
        );
        if (!parentOrgUnit || !parentOrgUnit.children) {
          console.warn(
            `findOrgUnitByName: Parent entity ${parentEntityName} not found or has no children.`
          );
          return null;
        }

        return parentOrgUnit.children.find(
          (childUnit) => childUnit.name === entityName
        );
      }

      // Default metrics if no risks are found
      function defaultMetrics() {
        return { priority: 1, velocity: 1, magnitude: 1, count: 0 };
      }

      // Example of metric calculation logic
      function calculateMetricsFromRisks(risks) {
        const priority =
          risks.reduce((sum, risk) => sum + (risk.priority || 0), 0) /
          risks.length;
        const velocity =
          risks.reduce((sum, risk) => sum + (risk.velocity || 0), 0) /
          risks.length;
        const magnitude =
          risks.reduce((sum, risk) => sum + (risk.magnitude || 0), 0) /
          risks.length;

        return { priority, velocity, magnitude, count: risks.length };
      }

      // Create an entity bubble (org, division, department, or BU)
      function createEntityBubble(
        entityType,
        entityName,
        parentEntityName,
        grandparentEntityName,
        metrics,
        timeIndex
      ) {
        try {
          // Debug the entity we're creating
          debugLog(`Creating ${entityType} bubble: ${entityName}`);

          // Safety checks
          if (!entityType || !entityName || !metrics) {
            debugLog("Warning: Missing required parameters for entity bubble");
            return null;
          }

          const bubble = document.createElement("div");
          bubble.classList.add("risk-bubble");
          bubble.dataset.type = entityType.toLowerCase();
          bubble.dataset.name = entityName;

          // Check if entity has no risks and apply appropriate styling
          const hasNoRisks = metrics.count === 0;
          if (hasNoRisks) {
            bubble.classList.add("no-risks");
            debugLog(`Entity ${entityName} has no risks`);
          }

          // Set size based on magnitude and number of risks
          const baseSize = 50;
          const size = hasNoRisks
            ? baseSize
            : baseSize +
              (metrics.magnitude - 1) * 10 +
              Math.min(metrics.count * 3, 30);
          bubble.style.width = `${size}px`;
          bubble.style.height = `${size}px`;

          // Position zero-risk entities in the safe zone at the bottom in a horizontal grid
          // Position entities with risks based on priority and velocity
          if (hasNoRisks) {
            // Get a consistent index for this entity, based on entity name
            // Using checksum-like approach for consistency between renders
            let entityIndex = 0;
            for (let i = 0; i < entityName.length; i++) {
              entityIndex += entityName.charCodeAt(i);
            }
            entityIndex = entityIndex % 10; // 0-9 range

            // Put all no-risk entities at the center bottom in a grid
            // with minimal horizontal spread
            const safeZoneHeight = 15; // The height of the safe zone
            const verticalPosition = 100 - safeZoneHeight / 2; // Vertically centered in safe zone

            // For horizontal position, create a grid in the middle 60% of the aquarium
            // This keeps all zero-risk entities in a central cluster at the bottom
            const column = entityIndex % 5; // 0-4
            const row = Math.floor(entityIndex / 5); // 0-1

            // Center the grid (20% to 80% horizontal range)
            const horizontalPosition = 20 + column * 12 + row * 6;

            bubble.style.top = `${verticalPosition}%`;
            bubble.style.left = `${horizontalPosition}%`;
          } else {
            // Normal positioning for entities with risks
            const verticalPosition =
              85 - ((metrics.priority - 1) * 15 + Math.random() * 5);
            bubble.style.top = `${verticalPosition}%`;

            const horizontalPosition =
              (metrics.velocity - 1) * 30 + Math.random() * 10;
            bubble.style.left = `${horizontalPosition}%`;
          }

          // Set color based on priority (default gray for no risks)
          const color = hasNoRisks
            ? "#888888"
            : getPriorityColor(metrics.priority);
          bubble.style.backgroundColor = color;

          // Add entity name
          const nameElement = document.createElement("div");
          nameElement.classList.add("fish-id");
          nameElement.textContent =
            entityName.length > 15
              ? entityName.substring(0, 12) + "..."
              : entityName;
          bubble.appendChild(nameElement);

          // Add tooltip on hover
          bubble.addEventListener("mouseenter", () => {
            if (!tooltip) return;

            if (hasNoRisks) {
              tooltip.innerHTML = `
                            <strong>${entityName}</strong><br>
                            No risks associated with this ${entityType}
                        `;
            } else {
              tooltip.innerHTML = `
                            <strong>${entityName}</strong><br>
                            ${metrics.count} Risk${
                metrics.count !== 1 ? "s" : ""
              }<br>
                            Avg. Magnitude: ${metrics.magnitude.toFixed(1)}<br>
                            Avg. Priority: ${metrics.priority.toFixed(1)}<br>
                            Avg. Velocity: ${metrics.velocity.toFixed(1)}
                        `;
            }

            const rect = bubble.getBoundingClientRect();
            tooltip.style.left = `${rect.left + rect.width / 2}px`;
            tooltip.style.top = `${rect.top}px`;
            tooltip.style.opacity = "1";
          });

          bubble.addEventListener("mouseleave", () => {
            if (!tooltip) return;
            tooltip.style.opacity = "0";
          });

          // Add floating animation (consolidated into a shared function)
          addFloatingAnimation(bubble);

          // Add click handler for drill-down if applicable
          bubble.addEventListener("click", () => {
            if (entityType.toLowerCase() === "organization") {
              // When clicking the organization, show all divisions
              debugLog("Org bubble clicked - showing divisions");
              setOrgLevel(1);
            } else if (entityType.toLowerCase() === "division") {
              // When clicking a division, filter to show only departments in that division
              debugLog(
                `Division ${entityName} clicked - showing its departments`
              );
              selectedDivision = entityName;
              selectedDepartment = null;
              selectedBU = null;
              setOrgLevel(2);
            } else if (entityType.toLowerCase() === "department") {
              // When clicking a department, filter to show only BUs in that department
              debugLog(`Department ${entityName} clicked - showing its BUs`);
              selectedDepartment = entityName;
              selectedDivision = parentEntityName;
              selectedBU = null;
              setOrgLevel(3);
            } else if (
              entityType.toLowerCase() === "businessunit" ||
              entityType.toLowerCase() === "bu"
            ) {
              // When clicking a BU, filter to show its risks
              debugLog(`BU ${entityName} clicked - showing its risks`);
              selectedBU = entityName;
              selectedDepartment = parentEntityName;
              selectedDivision = grandparentEntityName;
              // First show entity details, and give an option to see individual risks
              showEntityDetails(
                entityType,
                entityName,
                parentEntityName,
                grandparentEntityName,
                metrics,
                timeIndex
              );
            }
          });

          return bubble;
        } catch (error) {
          debugLog(
            `Error creating entity bubble for ${entityType}: ${entityName}`,
            error
          );
          return null;
        }
      }

      /* Show entity details in a popup
      function showEntityDetails(
        entityType,
        entityName,
        parentEntityName,
        grandparentEntityName,
        metrics,
        timeIndex
      ) {
        try {
          // Safety checks
          if (!entityType || !entityName) {
            debugLog("Warning: Missing required parameters for entity details");
            return;
          }

          // Remove existing popup if any
          const existingPopup = document.querySelector(".popup");
          const existingBackdrop = document.querySelector(".backdrop");

          if (existingPopup) {
            existingPopup.remove();
          }

          if (existingBackdrop) {
            existingBackdrop.remove();
          }

          // Create backdrop
          const backdrop = document.createElement("div");
          backdrop.classList.add("backdrop");
          document.body.appendChild(backdrop);

          // Create popup
          const popup = document.createElement("div");
          popup.classList.add("popup");

          // Get risks for this entity - use the same logic as calculateAggregatedRiskMetrics
          const type = (entityType || "").toLowerCase();
          let entityRisks = [];

          if (!data || !data.risks) {
            entityRisks = [];
          } else if (type === "organization") {
            entityRisks = data.risks;
          } else if (type === "division") {
            entityRisks = data.risks.filter((risk) => {
              return (
                risk.entity === entityName ||
                risk.parentEntity === entityName ||
                risk.grandparentEntity === entityName
              );
            });
          } else if (type === "department") {
            entityRisks = data.risks.filter((risk) => {
              return (
                risk.entity === entityName ||
                risk.parentEntity === entityName ||
                (risk.level === "bu" && risk.entity === entityName)
              );
            });
          } else if (type === "businessunit" || type === "bu") {
            entityRisks = data.risks.filter((risk) =>
              isBURisk(risk, entityName, parentEntityName)
            );
          }

          // Apply any active filters (preparation for future filtering feature)
          if (activeRiskFilters) {
            entityRisks = filterRisks(entityRisks, activeRiskFilters);
          }

          // Create popup content
          let hierarchyText = entityName;
          if (parentEntityName) hierarchyText += ` in ${parentEntityName}`;
          if (grandparentEntityName)
            hierarchyText += `, ${grandparentEntityName}`;

          // For entities with no risks, show a special message
          const hasNoRisks = !entityRisks || entityRisks.length === 0;

          popup.innerHTML = `
                    <div class="popup-content">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-xl font-bold">${
                              entityType.charAt(0).toUpperCase() +
                              entityType.slice(1)
                            }: ${hierarchyText}</h2>
                            <button class="close-popup text-gray-500 hover:text-gray-700">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                        
                        ${
                          hasNoRisks
                            ? `
                            <div class="p-6 text-center">
                                <div class="mb-4 text-gray-500 dark:text-gray-400">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                    </svg>
                                    <p class="text-lg">No risks are currently associated with this ${entityType}.</p>
                                </div>
                            </div>
                        `
                            : `
                            <div class="risk-metrics mb-4">
                                <div class="metric-card" style="border-left: 4px solid ${getPriorityColor(
                                  metrics.priority
                                )};">
                                    <div class="metric-label">Avg Priority</div>
                                    <div class="metric-value">${metrics.priority.toFixed(
                                      1
                                    )}</div>
                                </div>
                                
                                <div class="metric-card" style="border-left: 4px solid var(--velocity-${Math.round(
                                  metrics.velocity
                                )}-color);">
                                    <div class="metric-label">Avg Velocity</div>
                                    <div class="metric-value">${metrics.velocity.toFixed(
                                      1
                                    )}</div>
                                </div>
                                
                                <div class="metric-card">
                                    <div class="metric-label">Avg Magnitude</div>
                                    <div class="metric-value">${metrics.magnitude.toFixed(
                                      1
                                    )}</div>
                                </div>
                                
                                <div class="metric-card">
                                    <div class="metric-label">Total Risks</div>
                                    <div class="metric-value">${
                                      metrics.count
                                    }</div>
                                </div>
                            </div>
                            
                            ${
                              type === "businessunit" || type === "bu"
                                ? `
                                <div class="mt-4 mb-4 text-center">
                                    <button id="show-individual-risks" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded">
                                        Show Individual Risks
                                    </button>
                                </div>
                            `
                                : ""
                            }
                            
                            <h3 class="font-medium mb-2">Risks (${
                              entityRisks.length
                            })</h3>
                            <div class="overflow-x-auto">
                                <table class="min-w-full bg-white dark:bg-gray-800 rounded-lg overflow-hidden">
                                    <thead class="bg-gray-100 dark:bg-gray-700">
                                        <tr>
                                            <th class="px-4 py-2 text-left">ID</th>
                                            <th class="px-4 py-2 text-left">Title</th>
                                            <th class="px-4 py-2 text-left">Level</th>
                                            <th class="px-4 py-2 text-left">Priority</th>
                                            <th class="px-4 py-2 text-left">Velocity</th>
                                            <th class="px-4 py-2 text-left">Magnitude</th>
                                            <th class="px-4 py-2 text-left">Asset</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${entityRisks
                                          .map((risk) => {
                                            const timeData = risk.timeData?.[
                                              timeIndex
                                            ] || {
                                              priority: 3,
                                              velocity: 2,
                                              magnitude: 3,
                                            };
                                            return `
                                                <tr class="border-t border-gray-200 dark:border-gray-700">
                                                    <td class="px-4 py-2">${
                                                      risk.id || "Unknown"
                                                    }</td>
                                                    <td class="px-4 py-2">${
                                                      risk.title || "Untitled"
                                                    }</td>
                                                    <td class="px-4 py-2">${
                                                      risk.level || "Unknown"
                                                    }</td>
                                                    <td class="px-4 py-2">
                                                        <div class="flex items-center">
                                                            <div class="w-3 h-3 rounded-full mr-2" style="background-color: ${getPriorityColor(
                                                              timeData.priority
                                                            )};"></div>
                                                            P${Math.round(
                                                              timeData.priority
                                                            )}
                                                        </div>
                                                    </td>
                                                    <td class="px-4 py-2">V${Math.round(
                                                      timeData.velocity
                                                    )}</td>
                                                    <td class="px-4 py-2">${timeData.magnitude.toFixed(
                                                      1
                                                    )}</td>
                                                    <td class="px-4 py-2">${
                                                      risk.assetName || "N/A"
                                                    }</td>
                                                </tr>
                                            `;
                                          })
                                          .join("")}
                                    </tbody>
                                </table>
                            </div>
                        `
                        }
                    </div>
                `;

          document.body.appendChild(popup);

          // Add event listener to the "Show Individual Risks" button
          if (!hasNoRisks && (type === "businessunit" || type === "bu")) {
            const showRisksButton = popup.querySelector(
              "#show-individual-risks"
            );
            if (showRisksButton) {
              showRisksButton.addEventListener("click", () => {
                popup.remove();
                backdrop.remove();
                setOrgLevel(4); // Switch to individual risks view
              });
            }
          }

          // Close popup when clicking the close button
          const closeButton = popup.querySelector(".close-popup");
          if (closeButton) {
            closeButton.addEventListener("click", () => {
              popup.remove();
              backdrop.remove();
            });
          }

          // Close popup when clicking backdrop
          backdrop.addEventListener("click", () => {
            popup.remove();
            backdrop.remove();
          });

          // Close popup when pressing Escape key
          document.addEventListener("keydown", function closeOnEscape(e) {
            if (e.key === "Escape") {
              popup.remove();
              backdrop.remove();
              document.removeEventListener("keydown", closeOnEscape);
            }
          });
        } catch (error) {
          debugLog(
            `Error showing entity details for ${entityType}: ${entityName}`,
            error
          );
          // If we can't show the popup, at least log the error
        }
      } */

      // Helper function to set org level with proper slider position
      function setOrgLevel(level) {
        try {
          // Safety check
          if (!orgSlider || !timeSlider) return;

          // Set slider position
          orgSlider.value = level;

          // Get the current time index from the time slider
          const timeIndex = parseInt(timeSlider.value || 4); // Default to "Current" (4)

          // Update the aquarium with the current time index and organization level
          updateAquarium(timeIndex, level);
        } catch (error) {
          debugLog(`Error setting org level to ${level}:`, error);
        }
      }

      // Load data for a specific time index and update the visualization
      async function loadDataForTimeIndex(timeIndex) {
        try {
          // Check if we already have data for this index
          if (timeIndexedData[timeIndex]) {
            // Use existing data
            switchToTimeIndex(timeIndex);
            return true;
          }

          // Try to load the Excel file
          const workbook = await loadExcelFile(timeIndex);
          if (workbook) {
            // Process the workbook and store the data
            const processedData = processExcelWorkbook(workbook);
            timeIndexedData[timeIndex] = processedData;

            // Switch to this data
            switchToTimeIndex(timeIndex);
            return true;
          }
          return false;
        } catch (error) {
          console.error(
            `Error loading data for time index ${timeIndex}:`,
            error
          );
          const dataStatus = document.getElementById("data-status");
          if (dataStatus) {
            dataStatus.textContent = `Error loading data: ${error.message}`;
          }
          showLoading(false);
          return false;
        }
      } // eof loadDataForTimeIndex

      // Update aquarium based on selected time and organization level
      function updateAquarium(timeIndex, orgLevel) {
        try {
          console.log(
            `updating: Aquarium for time index ${timeIndex}, org level ${orgLevel}`
          );

          // Ensure required elements exist
          if (!aquarium) {
            console.error("updating: Aquarium element not found");
            return;
          }

          // Clear existing risk bubbles
          document
            .querySelectorAll(".risk-bubble")
            .forEach((bubble) => bubble.remove());

          // Update labels for time and organization level
          if (timeLabel) {
            const timeDescriptions = [
              "4 weeks ago",
              "3 weeks ago",
              "2 weeks ago",
              "1 week ago",
              "Current",
            ];
            timeLabel.textContent =
              timeDescriptions[timeIndex] || `Time ${timeIndex}`;
          }

          if (orgLevelIndicator) {
            const orgLevelDescriptions = [
              "Organization",
              "Divisions",
              "Departments",
              "Business Units",
              "Individual Risks",
            ];
            orgLevelIndicator.textContent =
              orgLevelDescriptions[orgLevel] || "Risk View";
          }

          // Make sure data exists for the current time index
          const currentData = timeIndexedData[timeIndex];
          if (!currentData || !currentData.risks || !currentData.orgStructure) {
            console.warn(
              `updating:  No data available for time index ${timeIndex}`
            );
            return;
          }

          console.log(
            "updating: Raw Organizational Structure data:",
            currentData.orgStructure
          );

          // Update safe zone visibility based on org level
          if (safeZone) {
            safeZone.style.display = orgLevel >= 3 ? "block" : "none";
          }

          // Render bubbles based on the organization level
          switch (orgLevel) {
            case 0: // Organization level
              const rootNode = currentData.orgStructure["1"]; // Access root node by ID
              if (!rootNode || !rootNode.name) {
                // Check lowercase "name" (normalized header)
                console.error(
                  "updating: Root node is undefined or missing a Name."
                );
                return;
              }

              console.log(
                `updating: Org Level 0: organization=${rootNode.name}`
              );

              // Calculate aggregated risk metrics for the organization
              const orgMetrics = calculateAggregatedRiskMetrics(
                "organization",
                rootNode.name,
                null,
                timeIndex
              );
              console.log(`updating: Org Metrics:`, orgMetrics);

              // Create the organization-level bubble
              const orgBubble = createEntityBubble(
                "organization",
                rootNode.name,
                null,
                null,
                orgMetrics,
                timeIndex
              );

              // Append the bubble to the aquarium if it's successfully created
              if (orgBubble) aquarium.appendChild(orgBubble);
              break;

            case 1: // Division level
              if (
                !currentData.orgStructure.divisions ||
                currentData.orgStructure.divisions.length === 0
              ) {
                console.warn(
                  `updating: No divisions available for org level 1.`
                );
                break;
              }

              currentData.orgStructure.divisions.forEach((division) => {
                const divisionMetrics = calculateAggregatedRiskMetrics(
                  "division",
                  division.name,
                  null,
                  timeIndex
                );
                const divisionBubble = createEntityBubble(
                  "division",
                  division.name,
                  null,
                  null,
                  divisionMetrics,
                  timeIndex
                );
                if (divisionBubble) aquarium.appendChild(divisionBubble);
              });
              break;

            case 2: // Department level
              if (
                !currentData.orgStructure.divisions ||
                currentData.orgStructure.divisions.length === 0
              ) {
                console.warn(
                  `updating: No divisions available for org level 2.`
                );
                break;
              }

              currentData.orgStructure.divisions.forEach((division) => {
                if (selectedDivision && division.name !== selectedDivision)
                  return;
                division.departments?.forEach((department) => {
                  const departmentMetrics = calculateAggregatedRiskMetrics(
                    "department",
                    department.name,
                    division.name,
                    timeIndex
                  );
                  const departmentBubble = createEntityBubble(
                    "department",
                    department.name,
                    division.name,
                    null,
                    departmentMetrics,
                    timeIndex
                  );
                  if (departmentBubble) aquarium.appendChild(departmentBubble);
                });
              });
              break;

            case 3: // Business Unit level
              if (
                !currentData.orgStructure.divisions ||
                currentData.orgStructure.divisions.length === 0
              ) {
                console.warn(
                  `updating: No divisions available for org level 3.`
                );
                break;
              }

              currentData.orgStructure.divisions.forEach((division) => {
                if (selectedDivision && division.name !== selectedDivision)
                  return;
                division.departments?.forEach((department) => {
                  if (
                    selectedDepartment &&
                    department.name !== selectedDepartment
                  )
                    return;
                  department.businessUnits?.forEach((bu) => {
                    const buMetrics = calculateAggregatedRiskMetrics(
                      "businessUnit",
                      bu,
                      department.name,
                      timeIndex
                    );
                    const buBubble = createEntityBubble(
                      "businessUnit",
                      bu,
                      department.name,
                      division.name,
                      buMetrics,
                      timeIndex
                    );
                    if (buBubble) aquarium.appendChild(buBubble);
                  });
                });
              });
              break;

            case 4: // Individual risks
              let risksToShow = currentData.risks;
              if (selectedBU && selectedDepartment) {
                risksToShow = risksToShow.filter((risk) =>
                  isBURisk(risk, selectedBU, selectedDepartment)
                );
              } else if (selectedDepartment && selectedDivision) {
                risksToShow = risksToShow.filter(
                  (risk) =>
                    risk.parentEntity === selectedDepartment &&
                    risk.grandparentEntity === selectedDivision
                );
              } else if (selectedDivision) {
                risksToShow = risksToShow.filter(
                  (risk) => risk.parentEntity === selectedDivision
                );
              }
              risksToShow.forEach((risk) => {
                const riskBubble = createRiskBubbleElement(risk, timeIndex);
                if (riskBubble) aquarium.appendChild(riskBubble);
              });
              break;

            default:
              console.warn(`updating: Unknown org level: ${orgLevel}`);
          } // end switch
        } catch (error) {
          console.error("updating: Error updating aquarium:", error);
        }
      }

      // Initialize bubbles
      createBubbles();

      // Load initial data and set up visualization
      (async function initialize() {
        try {
          // Show loading state
          showLoading(true);
          const dataStatus = document.getElementById("data-status");
          if (dataStatus) {
            dataStatus.textContent = "Loading initial data...";
          }

          // Start with the current time index (default to 4)
          const initialTimeIndex = 4;
          const initialOrgLevel = 0; // Default to "Organization" level

          // Load data for the initial time index
          const result = await loadDataForTimeIndex(initialTimeIndex);
          if (result) {
            // Switch to the initial time index
            switchToTimeIndex(initialTimeIndex);

            // Update the aquarium with the initial time index and organization level
            updateAquarium(initialTimeIndex, initialOrgLevel);

            // Set up time slider to switch between data periods
            // Initialize default slider values
            if (timeSlider && !timeSlider.value) {
              timeSlider.value = 4; // Default to "Current"
            }

            if (orgSlider && !orgSlider.value) {
              orgSlider.value = 0; // Default to "Organization"
            }

            // Set up time slider to switch between data periods
            if (timeSlider) {
              timeSlider.addEventListener("change", async function () {
                const timeIndex = parseInt(this.value);

                if (isNaN(timeIndex) || timeIndex < 0 || timeIndex > 4) {
                  console.error(`Invalid time index: ${timeIndex}`);
                  return;
                }

                const orgLevel = parseInt(orgSlider?.value || 0);

                showLoading(true);
                const result = await loadDataForTimeIndex(timeIndex);
                if (result) {
                  switchToTimeIndex(timeIndex);
                  updateAquarium(timeIndex, orgLevel);
                } else {
                  console.warn(`No data available for time index ${timeIndex}`);
                  if (dataStatus) {
                    dataStatus.textContent = `No data available for time index ${timeIndex}`;
                  }
                }
                showLoading(false);
              });

              // Trigger the time slider change event on page load
              timeSlider.dispatchEvent(new Event("change"));
            }

            // Set up organization slider (orgSlider) to change organization levels
            if (orgSlider) {
              orgSlider.addEventListener("input", function () {
                const timeIndex = parseInt(timeSlider?.value || 4);
                const orgLevel = parseInt(this.value);

                if (isNaN(orgLevel) || orgLevel < 0 || orgLevel > 4) {
                  console.error(`Invalid organization level: ${orgLevel}`);
                  return;
                }

                updateAquarium(timeIndex, orgLevel);
              });

              // Trigger the organization slider input event on page load
              orgSlider.dispatchEvent(new Event("input"));
            }

            // Initial update
            if (dataStatus) {
              dataStatus.textContent = "Data loaded successfully";
            }
          } else {
            if (dataStatus) {
              dataStatus.textContent =
                "Failed to load initial data. Please try manual file upload below.";
            }
          }

          // Hide loading state
          showLoading(false);
        } catch (error) {
          console.error("Error during initialization:", error);
          const dataStatus = document.getElementById("data-status");
          if (dataStatus) {
            dataStatus.textContent = `Error initializing: ${error.message}. Please try manual file upload.`;
          }
          showLoading(false);
        }
      })();

      // Handle window resize
      window.addEventListener("resize", () => {
        try {
          // Get the current time index and org level from the sliders
          const timeIndex = parseInt(timeSlider?.value || 4); // Default to "Current" (4)
          const orgLevel = parseInt(orgSlider?.value || 0); // Default to "Organization" (0)

          // Update the aquarium with the current time index and org level
          updateAquarium(timeIndex, orgLevel);
          createBubbles(); // Recreate the bubbles (if needed for visualization)
        } catch (error) {
          console.error("Error handling window resize:", error);
        }
      });
    </script>
  </body>
</html>
