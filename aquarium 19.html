<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Risk Aquarium Visualization</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <!-- Add this first to block all sourcemap requests -->
    <meta http-equiv="x-sourcemap" content="no-source-map" />

    <script>
      // Completely disable Chart.js sourcemap functionality
      window.Chart = window.Chart || {};
      window.Chart.defaults = window.Chart.defaults || {};
      window.Chart.defaults.plugins = window.Chart.defaults.plugins || {};
      window.Chart.defaults.plugins.sourceMap = false;
    </script>
    <!-- Load the explicit UMD build with version pinning -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <!-- Add SheetJS library for Excel parsing -->
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <style>
      :root {
        --priority-1-color: #3b82f6; /* Blue */
        --priority-2-color: #10b981; /* Green */
        --priority-3-color: #facc15; /* Yellow */
        --priority-4-color: #f97316; /* Orange */
        --priority-5-color: #ef4444; /* Red */

        --velocity-1-color: #93c5fd; /* Light blue */
        --velocity-2-color: #60a5fa; /* Medium blue */
        --velocity-3-color: #2563eb; /* Dark blue */
      }

      body {
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      .dark {
        background-color: #181818;
        color: #ffffff;
      }

      .light {
        background-color: #ffffff;
        color: #181818;
      }

      .aquarium {
        background: linear-gradient(
          to bottom,
          rgba(173, 216, 230, 0.2),
          rgba(0, 0, 128, 0.4)
        );
        border: 2px solid #5d5cde;
        border-radius: 8px;
        overflow: hidden;
        position: relative;
      }

      .aquarium::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(
            circle at 10% 20%,
            rgba(255, 255, 255, 0.03) 0%,
            rgba(255, 255, 255, 0) 20%
          ),
          radial-gradient(
            circle at 80% 30%,
            rgba(255, 255, 255, 0.03) 0%,
            rgba(255, 255, 255, 0) 20%
          );
        pointer-events: none;
      }

      .risk-bubble {
        position: absolute;
        transform-origin: center;
        transition: all 0.5s ease-in-out;
        cursor: pointer;
        filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.3));
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background: radial-gradient(
          circle at 30% 30%,
          rgba(255, 255, 255, 0.5),
          rgba(255, 255, 255, 0.1)
        );
        z-index: 5; /* Base z-index for all bubbles */
      }

      /* Style for entities with zero risks */
      .no-risks {
        opacity: 0.6;
        border: 1px dashed #888;
      }

      /* Highlight effect for hovered bubbles */
      .risk-bubble:hover {
        z-index: 50; /* Higher z-index when hovered */
        filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.5));
        transform: scale(1.05);
      }

      .fish-id {
        position: relative;
        z-index: 2;
        font-weight: bold;
        color: white;
        text-shadow: 0 0 3px black;
        font-size: 10px;
        text-align: center;
        pointer-events: none;
      }

      .time-slider-container {
        width: calc(100% - 80px);
        margin-left: 70px;
        padding: 10px 0;
      }

      .org-slider-container {
        position: relative;
        width: 70px;
        margin-right: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 10px;
        z-index: 10;
        border-radius: 8px 0 0 8px;
      }

      .horizontal-slider {
        width: 100%;
        appearance: none;
        height: 8px;
        background: #d3d3d3;
        outline: none;
        border-radius: 4px;
      }

      .vertical-slider {
        appearance: none;
        width: 20px;
        height: 80%;
        background: #d3d3d3;
        outline: none;
        border-radius: 4px;
        writing-mode: bt-lr; /* Vertical orientation */
        -webkit-appearance: slider-vertical;
        transform: rotate(180deg); /* Fixes the reversal issue */
      }

      .dark .org-slider-container {
        background-color: rgba(40, 40, 50, 0.7);
        border-color: #444;
      }

      .horizontal-slider::-webkit-slider-thumb,
      .vertical-slider::-webkit-slider-thumb {
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #5d5cde;
        cursor: pointer;
      }

      .horizontal-slider::-moz-range-thumb,
      .vertical-slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #5d5cde;
        cursor: pointer;
      }

      .vertical-slider-labels {
        position: absolute;
        right: 3px;
        height: 80%;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        font-size: 0.75rem;
        padding: 5px 0;
      }

      .vertical-slider-labels span {
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
        transition: background-color 0.2s;
      }

      .vertical-slider-labels span:hover {
        background-color: rgba(93, 92, 222, 0.1);
      }

      .popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border: 2px solid #5d5cde;
        border-radius: 8px;
        padding: 20px;
        max-width: 600px;
        width: 90%;
        z-index: 1000;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      }

      .popup-content {
        max-height: 80vh;
        overflow-y: auto;
      }

      .dark .popup {
        background-color: #2d2d2d;
        color: white;
      }

      .backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 999;
      }

      .tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 100;
        pointer-events: none;
        white-space: nowrap;
        transform: translate(-50%, -100%);
        top: -10px;
        opacity: 0;
        transition: opacity 0.2s;
      }

      .bubbles {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }

      .bubble {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        animation: bubble-rise linear infinite;
      }

      @keyframes bubble-rise {
        0% {
          transform: translateY(0) translateX(0);
          opacity: 0.7;
        }
        100% {
          transform: translateY(-100vh) translateX(20px);
          opacity: 0;
        }
      }

      .org-level-label {
        position: absolute;
        right: 10px;
        font-weight: bold;
        background-color: rgba(93, 92, 222, 0.1);
        padding: 5px 10px;
        border-radius: 4px;
        border-left: 4px solid #5d5cde;
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .fish-id {
          font-size: 8px;
        }

        .controls-container {
          flex-direction: column;
        }
      }

      /* Legend sizing */
      .legend-container {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 0.25rem;
        font-size: 0.75rem;
        width: calc(100% - 80px);
        margin-left: 70px;
        margin-top: 0.5rem;
      }

      .legend-item {
        padding: 0.25rem 0.5rem;
        border: 1px solid #ddd;
        border-radius: 0.25rem;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      }

      .legend-title {
        font-weight: 600;
        margin-bottom: 0.25rem;
        font-size: 0.7rem;
      }

      .legend-entry {
        display: flex;
        align-items: center;
        margin-bottom: 0.125rem;
      }

      .legend-color {
        width: 0.6rem;
        height: 0.6rem;
        border-radius: 9999px;
        margin-right: 0.375rem;
      }

      /* Dark mode toggle */
      .theme-toggle {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        cursor: pointer;
        background: none;
        border: none;
        color: inherit;
        font-size: 1.2rem;
      }

      /* Risk details popup */
      .risk-metrics {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 15px;
      }

      .metric-card {
        flex: 1;
        min-width: 120px;
        padding: 10px;
        border-radius: 6px;
        border: 1px solid #ddd;
        text-align: center;
      }

      .dark .metric-card {
        border-color: #444;
      }

      .metric-value {
        font-size: 1.5rem;
        font-weight: bold;
        margin: 5px 0;
      }

      .metric-label {
        font-size: 0.8rem;
        color: #666;
      }

      .dark .metric-label {
        color: #aaa;
      }

      .trend-container {
        height: 150px; /* Fixed height for chart */
        margin-top: 10px;
      }

      /* Loading indicator */
      .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
        color: white;
        font-size: 1.2rem;
      }

      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top: 4px solid white;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }
    </style>
  </head>
  <body class="min-h-screen p-4 transition-colors">
    <button class="theme-toggle" aria-label="Toggle dark/light mode">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-6 w-6 theme-icon-dark hidden"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
        />
      </svg>
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-6 w-6 theme-icon-light"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
        />
      </svg>
    </button>

    <div class="max-w-7xl mx-auto">
      <h1 class="text-3xl font-bold mb-4 text-center">Risk Aquarium</h1>

      <div class="mb-4 relative flex">
        <div class="org-slider-container">
          <input
            type="range"
            min="0"
            max="4"
            value="0"
            class="vertical-slider"
            id="org-slider"
          />
          <div class="vertical-slider-labels">
            <span id="label-org" onclick="setOrgLevel(0)">Org</span>
            <span id="label-div" onclick="setOrgLevel(1)">Div</span>
            <span id="label-dept" onclick="setOrgLevel(2)">Dept</span>
            <span id="label-bu" onclick="setOrgLevel(3)">BU</span>
            <span id="label-risks" onclick="setOrgLevel(4)">Risks</span>
          </div>
        </div>
        <div
          class="aquarium flex-grow"
          id="aquarium"
          style="height: 60vh; width: calc(100% - 80px)"
        >
          <div class="bubbles" id="bubbles"></div>
          <div id="org-level-indicator" class="org-level-label">
            Organization
          </div>
        </div>
      </div>

      <div class="mt-2 controls-container">
        <div class="time-slider-container">
          <label for="time-slider" class="block mb-2 font-medium"
            >Time: <span id="time-label">Current</span></label
          >
          <input
            type="range"
            min="0"
            max="4"
            value="4"
            class="horizontal-slider"
            id="time-slider"
          />
          <div class="flex justify-between text-xs mt-1">
            <span>4 weeks ago</span>
            <span>3 weeks ago</span>
            <span>2 weeks ago</span>
            <span>1 week ago</span>
            <span>Current</span>
          </div>
        </div>
      </div>

      <div class="legend-container">
        <div class="legend-item">
          <div class="legend-title">Priority Legend</div>
          <!-- Reordered to match aquarium - high priority at top, low at bottom -->
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--priority-5-color)"
            ></div>
            <span>P5 - High</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--priority-4-color)"
            ></div>
            <span>P4</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--priority-3-color)"
            ></div>
            <span>P3</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--priority-2-color)"
            ></div>
            <span>P2</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--priority-1-color)"
            ></div>
            <span>P1 - Low</span>
          </div>
        </div>

        <div class="legend-item">
          <div class="legend-title">Velocity Legend</div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--velocity-3-color)"
            ></div>
            <span>V3 - Fast</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--velocity-2-color)"
            ></div>
            <span>V2</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="background-color: var(--velocity-1-color)"
            ></div>
            <span>V1 - Slow</span>
          </div>
        </div>

        <div class="legend-item">
          <div class="legend-title">Size Legend</div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="width: 0.9rem; height: 0.9rem; border: 1px solid #ccc"
            ></div>
            <span>Large - High Impact</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="width: 0.7rem; height: 0.7rem; border: 1px solid #ccc"
            ></div>
            <span>Medium</span>
          </div>
          <div class="legend-entry">
            <div
              class="legend-color"
              style="width: 0.5rem; height: 0.5rem; border: 1px solid #ccc"
            ></div>
            <span>Small - Low Impact</span>
          </div>
          <div class="legend-entry mt-2">
            <div
              class="legend-color opacity-40"
              style="width: 0.7rem; height: 0.7rem; border: 1px dashed #888"
            ></div>
            <span>No Risks</span>
          </div>
        </div>
      </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <script>
      // CONFIGURABLE CONSTANTS FOR DEMO
      // These can be easily adjusted for demo purposes
      const CONFIG = {
        // Number of organizational units
        DIVISIONS: 2,
        DEPARTMENTS_PER_DIVISION: 2,
        BUS_PER_DEPARTMENT: 2,

        // Total number of risks - will be distributed across all levels
        TOTAL_RISKS: 30,

        // Distribution percentages for different levels
        ORG_LEVEL_PERCENTAGE: 0.05, // 15% at org level
        DIVISION_LEVEL_PERCENTAGE: 0.15, // 20% at division level
        DEPARTMENT_LEVEL_PERCENTAGE: 0.25, // 25% at department level
        BU_LEVEL_PERCENTAGE: 0.55, // 40% at BU level

        // Risk parameters
        MIN_PRIORITY: 1,
        MAX_PRIORITY: 5,
        MIN_VELOCITY: 1,
        MAX_VELOCITY: 3,
        MIN_MAGNITUDE: 1,
        MAX_MAGNITUDE: 5,
      };

      const AppState = {
        current: {
          timeIndex: 4,
          orgLevel: 0,
          risks: [],
          orgStructure: null,
        },
        timeIndexedData: {},
      };

      // Time-indexed data storage - store separate datasets for each time period
      const timeIndexedData = {
        0: null, // 4 weeks ago
        1: null, // 3 weeks ago
        2: null, // 2 weeks ago
        3: null, // 1 week ago
        4: null, // Current
      };

      // File mapping in reverse order to match logical time flow
      const weekFiles = [
        "week_04.xlsx",
        "week_03.xlsx",
        "week_02.xlsx",
        "week_01.xlsx",
        "week_00.xlsx",
      ];

      /* Add file upload handler for manual loading
      const fileInput = document.getElementById("file-input");
      const fileList = document.getElementById("file-list");
      const uploadedFiles = {};

      fileInput.addEventListener("change", function (e) {
        const files = e.target.files;
        fileList.innerHTML = "";

        Array.from(files).forEach((file) => {
          const reader = new FileReader();
          reader.onload = function (event) {
            try {
              const data = new Uint8Array(event.target.result);
              const workbook = XLSX.read(data, { type: "array" });

              // Store workbook by filename
              uploadedFiles[file.name] = workbook;
              fileList.innerHTML += `<div>${file.name} - Loaded successfully</div>`;

              // Process the workbook and store it in timeIndexedData
              const match = file.name.match(/week_(\d+)\.xlsx/i);
              if (match) {
                const weekNum = parseInt(match[1]);
                const timeIndex = weekNum === 0 ? 4 : 4 - weekNum; // Map week 00 to index 4
                const processedData = processExcelWorkbook(workbook);
                timeIndexedData[timeIndex] = processedData;
                debugLog(
                  `Stored processed data for time index ${timeIndex} (${file.name})`
                );
              }
            } catch (error) {
              fileList.innerHTML += `<div class="text-red-500">${file.name} - Error: ${error.message}</div>`;
              console.error(
                `Error processing uploaded file ${file.name}:`,
                error
              );
            }
          };
          reader.readAsArrayBuffer(file);
        });
      });
      */

      // Theme detection and toggle
      const prefersDarkScheme = window.matchMedia(
        "(prefers-color-scheme: dark)"
      );
      const body = document.body;
      const themeToggle = document.querySelector(".theme-toggle");
      const darkIcon = document.querySelector(".theme-icon-dark");
      const lightIcon = document.querySelector(".theme-icon-light");

      // Debug logging - keep intact for upcoming filtering feature
      function debugLog(message, data = null) {
        if (!CONFIG.DEBUG) return;

        try {
          const debugOverlay = document.getElementById("debug-overlay");
          if (!debugOverlay) return; // Safety check

          const timestamp = new Date().toLocaleTimeString();
          let logMessage = `<div class="mb-1"><span class="opacity-50">${timestamp}</span> ${message}</div>`;

          if (data) {
            try {
              // For objects, stringify them
              if (typeof data === "object") {
                const stringified = JSON.stringify(data, null, 2)
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;");
                logMessage += `<pre class="text-xs bg-black bg-opacity-50 p-1 my-1 rounded overflow-auto max-h-20">${stringified}</pre>`;
              } else {
                logMessage += `<pre class="text-xs bg-black bg-opacity-50 p-1 my-1 rounded">${data}</pre>`;
              }
            } catch (e) {
              logMessage += `<div class="text-red-300">[Error displaying data: ${e.message}]</div>`;
            }
          }

          debugOverlay.innerHTML = logMessage + debugOverlay.innerHTML;

          // Limit the amount of debug messages to prevent browser slowdown
          if (debugOverlay.children.length > 20) {
            debugOverlay.lastChild.remove();
          }

          // Also log to console
          console.log(message, data);
        } catch (error) {
          // Fail silently - debug logging should never break the application
          console.log("Debug log error:", error);
        }
      }

      function setTheme(isDark) {
        if (isDark) {
          body.classList.add("dark");
          body.classList.remove("light");
          darkIcon.classList.remove("hidden");
          lightIcon.classList.add("hidden");
        } else {
          body.classList.add("light");
          body.classList.remove("dark");
          darkIcon.classList.add("hidden");
          lightIcon.classList.remove("hidden");
        }
      }

      // Set initial theme based on system preference
      setTheme(prefersDarkScheme.matches);

      // Toggle theme when button is clicked
      themeToggle.addEventListener("click", () => {
        const isDark = body.classList.contains("dark");
        setTheme(!isDark);
      });

      // Update theme if system preference changes
      prefersDarkScheme.addEventListener("change", (e) => {
        setTheme(e.matches);
      });

      // Generate random risks data
      function generateRisksData() {
        // Create organizational structure based on configuration
        const orgStructure = {
          organization: "Global Enterprise",
          divisions: [],
        };

        // Generate divisions based on CONFIG
        for (let divIdx = 0; divIdx < CONFIG.DIVISIONS; divIdx++) {
          const division = {
            name: `Division ${divIdx + 1}`,
            departments: [],
          };

          // Generate departments for this division
          for (
            let deptIdx = 0;
            deptIdx < CONFIG.DEPARTMENTS_PER_DIVISION;
            deptIdx++
          ) {
            const department = {
              name: `Department ${divIdx + 1}-${deptIdx + 1}`,
              businessUnits: [],
            };

            // Generate business units for this department
            for (let buIdx = 0; buIdx < CONFIG.BUS_PER_DEPARTMENT; buIdx++) {
              department.businessUnits.push(
                `BU ${divIdx + 1}-${deptIdx + 1}-${buIdx + 1}`
              );
            }

            division.departments.push(department);
          }

          orgStructure.divisions.push(division);
        }

        // Calculate risks per level based on percentages and total
        const orgLevelRisks = Math.round(
          CONFIG.TOTAL_RISKS * CONFIG.ORG_LEVEL_PERCENTAGE
        );
        const divisionLevelRisks = Math.round(
          CONFIG.TOTAL_RISKS * CONFIG.DIVISION_LEVEL_PERCENTAGE
        );
        const departmentLevelRisks = Math.round(
          CONFIG.TOTAL_RISKS * CONFIG.DEPARTMENT_LEVEL_PERCENTAGE
        );
        const buLevelRisks =
          CONFIG.TOTAL_RISKS -
          (orgLevelRisks + divisionLevelRisks + departmentLevelRisks);

        const riskCategories = [
          "Strategic",
          "Operational",
          "Financial",
          "Compliance",
          "Technological",
          "Reputational",
          "Market",
          "Legal",
        ];

        const risks = [];
        let riskId = 1;

        // Helper to select random element from array
        const randomFrom = (arr) => arr[Math.floor(Math.random() * arr.length)];

        // Helper to generate a random number within a range
        const randomInRange = (min, max) =>
          Math.floor(Math.random() * (max - min + 1)) + min;

        // Helper to generate consistent but changing data over time
        const generateTimeData = (baseValue, id, weekIndex) => {
          // Use the risk ID as a seed for consistent but varied changes
          const seed = id * 0.1;
          // Generate change pattern based on week and ID
          const changePattern = Math.sin(weekIndex + seed) * 0.2;
          // Calculate new value with bounds
          let newValue = baseValue + changePattern;
          return Math.max(
            CONFIG.MIN_PRIORITY,
            Math.min(CONFIG.MAX_PRIORITY, newValue)
          );
        };

        // Generate org-level risks
        for (let i = 0; i < orgLevelRisks; i++) {
          const priority = randomInRange(
            CONFIG.MIN_PRIORITY,
            CONFIG.MAX_PRIORITY
          );
          const velocity = randomInRange(
            CONFIG.MIN_VELOCITY,
            CONFIG.MAX_VELOCITY
          );
          const magnitude = randomInRange(
            CONFIG.MIN_MAGNITUDE,
            CONFIG.MAX_MAGNITUDE
          );

          const risk = {
            id: `R${riskId}`,
            title: `${randomFrom(riskCategories)} Risk ${riskId}`,
            description: `This is a ${randomFrom(
              riskCategories
            ).toLowerCase()} risk affecting the organization`,
            owner: `Owner ${Math.ceil(Math.random() * 10)}`,
            level: "organization",
            entity: orgStructure.organization,
            category: randomFrom(riskCategories),
            timeData: [
              {
                week: 0,
                priority: generateTimeData(priority, riskId, 0),
                velocity: generateTimeData(velocity, riskId, 0),
                magnitude: generateTimeData(magnitude, riskId, 0),
              },
              {
                week: 1,
                priority: generateTimeData(priority, riskId, 1),
                velocity: generateTimeData(velocity, riskId, 1),
                magnitude: generateTimeData(magnitude, riskId, 1),
              },
              {
                week: 2,
                priority: generateTimeData(priority, riskId, 2),
                velocity: generateTimeData(velocity, riskId, 2),
                magnitude: generateTimeData(magnitude, riskId, 2),
              },
              {
                week: 3,
                priority: generateTimeData(priority, riskId, 3),
                velocity: generateTimeData(velocity, riskId, 3),
                magnitude: generateTimeData(magnitude, riskId, 3),
              },
              { week: 4, priority, velocity, magnitude },
            ],
            mitigationPlan: `Implement ${randomFrom([
              "monitoring",
              "controls",
              "training",
              "automation",
              "policies",
            ])} to reduce impact`,
          };

          risks.push(risk);
          riskId++;
        }

        // Create arrays for all available divisions, departments, and BUs
        const allDivisions = [];
        const allDepartments = [];
        const allBUs = [];

        orgStructure.divisions.forEach((division) => {
          allDivisions.push(division.name);

          division.departments.forEach((department) => {
            allDepartments.push({
              name: department.name,
              division: division.name,
            });

            department.businessUnits.forEach((bu) => {
              allBUs.push({
                name: bu,
                department: department.name,
                division: division.name,
              });
            });
          });
        });

        // Generate division-level risks - randomly assign to divisions
        for (let i = 0; i < divisionLevelRisks; i++) {
          const randomDivision = randomFrom(allDivisions);
          const priority = randomInRange(
            CONFIG.MIN_PRIORITY,
            CONFIG.MAX_PRIORITY
          );
          const velocity = randomInRange(
            CONFIG.MIN_VELOCITY,
            CONFIG.MAX_VELOCITY
          );
          const magnitude = randomInRange(
            CONFIG.MIN_MAGNITUDE,
            CONFIG.MAX_MAGNITUDE
          );

          const risk = {
            id: `R${riskId}`,
            title: `${randomFrom(riskCategories)} Risk ${riskId}`,
            description: `This is a ${randomFrom(
              riskCategories
            ).toLowerCase()} risk affecting ${randomDivision}`,
            owner: `Owner ${Math.ceil(Math.random() * 10)}`,
            level: "division",
            entity: randomDivision,
            category: randomFrom(riskCategories),
            timeData: [
              {
                week: 0,
                priority: generateTimeData(priority, riskId, 0),
                velocity: generateTimeData(velocity, riskId, 0),
                magnitude: generateTimeData(magnitude, riskId, 0),
              },
              {
                week: 1,
                priority: generateTimeData(priority, riskId, 1),
                velocity: generateTimeData(velocity, riskId, 1),
                magnitude: generateTimeData(magnitude, riskId, 1),
              },
              {
                week: 2,
                priority: generateTimeData(priority, riskId, 2),
                velocity: generateTimeData(velocity, riskId, 2),
                magnitude: generateTimeData(magnitude, riskId, 2),
              },
              {
                week: 3,
                priority: generateTimeData(priority, riskId, 3),
                velocity: generateTimeData(velocity, riskId, 3),
                magnitude: generateTimeData(magnitude, riskId, 3),
              },
              { week: 4, priority, velocity, magnitude },
            ],
            mitigationPlan: `Implement ${randomFrom([
              "monitoring",
              "controls",
              "training",
              "automation",
              "policies",
            ])} to reduce impact`,
          };

          risks.push(risk);
          riskId++;
        }

        // Generate department-level risks - randomly assign to departments
        for (let i = 0; i < departmentLevelRisks; i++) {
          const randomDept = randomFrom(allDepartments);
          const priority = randomInRange(
            CONFIG.MIN_PRIORITY,
            CONFIG.MAX_PRIORITY
          );
          const velocity = randomInRange(
            CONFIG.MIN_VELOCITY,
            CONFIG.MAX_VELOCITY
          );
          const magnitude = randomInRange(
            CONFIG.MIN_MAGNITUDE,
            CONFIG.MAX_MAGNITUDE
          );

          const risk = {
            id: `R${riskId}`,
            title: `${randomFrom(riskCategories)} Risk ${riskId}`,
            description: `This is a ${randomFrom(
              riskCategories
            ).toLowerCase()} risk affecting ${randomDept.name} in ${
              randomDept.division
            }`,
            owner: `Owner ${Math.ceil(Math.random() * 10)}`,
            level: "department",
            entity: randomDept.name,
            parentEntity: randomDept.division,
            category: randomFrom(riskCategories),
            timeData: [
              {
                week: 0,
                priority: generateTimeData(priority, riskId, 0),
                velocity: generateTimeData(velocity, riskId, 0),
                magnitude: generateTimeData(magnitude, riskId, 0),
              },
              {
                week: 1,
                priority: generateTimeData(priority, riskId, 1),
                velocity: generateTimeData(velocity, riskId, 1),
                magnitude: generateTimeData(magnitude, riskId, 1),
              },
              {
                week: 2,
                priority: generateTimeData(priority, riskId, 2),
                velocity: generateTimeData(velocity, riskId, 2),
                magnitude: generateTimeData(magnitude, riskId, 2),
              },
              {
                week: 3,
                priority: generateTimeData(priority, riskId, 3),
                velocity: generateTimeData(velocity, riskId, 3),
                magnitude: generateTimeData(magnitude, riskId, 3),
              },
              { week: 4, priority, velocity, magnitude },
            ],
            mitigationPlan: `Implement ${randomFrom([
              "monitoring",
              "controls",
              "training",
              "automation",
              "policies",
            ])} to reduce impact`,
          };

          risks.push(risk);
          riskId++;
        }

        // Generate BU-level risks - randomly assign to business units
        for (let i = 0; i < buLevelRisks; i++) {
          const randomBU = randomFrom(allBUs);
          const priority = randomInRange(
            CONFIG.MIN_PRIORITY,
            CONFIG.MAX_PRIORITY
          );
          const velocity = randomInRange(
            CONFIG.MIN_VELOCITY,
            CONFIG.MAX_VELOCITY
          );
          const magnitude = randomInRange(
            CONFIG.MIN_MAGNITUDE,
            CONFIG.MAX_MAGNITUDE
          );

          const risk = {
            id: `R${riskId}`,
            title: `${randomFrom(riskCategories)} Risk ${riskId}`,
            description: `This is a ${randomFrom(
              riskCategories
            ).toLowerCase()} risk affecting ${randomBU.name} in ${
              randomBU.department
            }, ${randomBU.division}`,
            owner: `Owner ${Math.ceil(Math.random() * 10)}`,
            level: "businessUnit",
            entity: randomBU.name,
            parentEntity: randomBU.department,
            grandparentEntity: randomBU.division,
            category: randomFrom(riskCategories),
            timeData: [
              {
                week: 0,
                priority: generateTimeData(priority, riskId, 0),
                velocity: generateTimeData(velocity, riskId, 0),
                magnitude: generateTimeData(magnitude, riskId, 0),
              },
              {
                week: 1,
                priority: generateTimeData(priority, riskId, 1),
                velocity: generateTimeData(velocity, riskId, 1),
                magnitude: generateTimeData(magnitude, riskId, 1),
              },
              {
                week: 2,
                priority: generateTimeData(priority, riskId, 2),
                velocity: generateTimeData(velocity, riskId, 2),
                magnitude: generateTimeData(magnitude, riskId, 2),
              },
              {
                week: 3,
                priority: generateTimeData(priority, riskId, 3),
                velocity: generateTimeData(velocity, riskId, 3),
                magnitude: generateTimeData(magnitude, riskId, 3),
              },
              { week: 4, priority, velocity, magnitude },
            ],
            mitigationPlan: `Implement ${randomFrom([
              "monitoring",
              "controls",
              "training",
              "automation",
              "policies",
            ])} to reduce impact`,
          };

          risks.push(risk);
          riskId++;
        }

        return {
          risks,
          orgStructure,
        };
      }

      // Helper function to show/hide loading indicator
      function showLoading(isLoading) {
        try {
          let loadingOverlay = document.querySelector(".loading-overlay");

          if (isLoading) {
            if (!loadingOverlay) {
              loadingOverlay = document.createElement("div");
              loadingOverlay.className = "loading-overlay";

              const spinner = document.createElement("div");
              spinner.className = "spinner";

              const text = document.createElement("div");
              text.textContent = "Loading data...";

              loadingOverlay.appendChild(spinner);
              loadingOverlay.appendChild(text);

              const aquarium = document.getElementById("aquarium");
              if (aquarium) {
                aquarium.appendChild(loadingOverlay);
              }
            }
          } else if (loadingOverlay) {
            loadingOverlay.remove();
          }
        } catch (error) {
          console.error("Error toggling loading indicator:", error);
          // Fail silently - loading indicator should never break the application
        }
      }

      let data = null;

      async function loadExcelFile(timeIndex) {
        const filename = weekFiles[timeIndex]; // File corresponding to the current timeIndex
        // const dataStatus = document.getElementById("data-status");

        try {
          /* Check if the file has already been uploaded
          if (uploadedFiles[filename]) {
            debugLog(
              `Using uploaded file ${filename} for time index ${timeIndex}`
            );
            dataStatus.textContent = `Data loaded from uploaded: ${filename}`;
            return uploadedFiles[filename];
          }

          // Check if data for this time index is already processed
          if (timeIndexedData[timeIndex]) {
            debugLog(`Using cached data for time index ${timeIndex}`);
            dataStatus.textContent = `Using cached data for time period ${
              timeLabel?.textContent || timeIndex
            }`;
            return null; // File does not need to be reloaded or reprocessed
          }
          */
          // Show loading state
          showLoading(true);
          // dataStatus.textContent = `Loading data from ${filename}...`;

          // Fetch the file using the Fetch API
          const response = await fetch(`./data/${filename}`);
          if (!response.ok) {
            throw new Error(
              `loadExcelFile: Failed to fetch file: HTTP status ${response.status}`
            );
          }

          // Read the response as an ArrayBuffer
          const arrayBuffer = await response.arrayBuffer();

          // Parse the file using SheetJS (XLSX library)
          const data = new Uint8Array(arrayBuffer);
          const workbook = XLSX.read(data, { type: "array" });

          // Update status
          // dataStatus.textContent = `Data loaded from ${filename}`;
          debugLog(
            `loadExcelFile: Successfully loaded workbook for time index ${timeIndex}`
          );

          return workbook;
        } catch (error) {
          // Handle errors gracefully and inform the user
          console.error(
            `loadExcelFile: Error loading Excel file for time index ${timeIndex}:`,
            error
          );
          /*
          if (dataStatus) {
            dataStatus.textContent = `Error loading data for ${filename}: ${error.message}`;
          }
          */
          // Return null to indicate the file could not be processed
          return null;
        } finally {
          // Hide the loading indicator
          showLoading(false);
        }
      } // end of loadExcelFile

      function parseOrgStructure(sheet) {
        console.log("parseOrgStructure: Starting org structure parsing...");
        console.log("parseOrgStructure: Raw sheet data:", sheet);

        if (!sheet) {
          console.error(
            "parseOrgStructure: Organizational Structure sheet is missing!"
          );
          return {};
        }

        // Convert sheet to JSON, reading rows as raw arrays
        const rows = XLSX.utils.sheet_to_json(sheet, {
          defval: null,
          header: 1, // Read as raw rows
        });

        console.log("parseOrgStructure: Raw rows from sheet:", rows);

        // **DYNAMIC HEADER ROW DETECTION**
        let headerRowIndex = -1;
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          if (
            row.includes("ID") &&
            row.includes("Parent_ID") &&
            row.includes("Name")
          ) {
            headerRowIndex = i;
            break;
          }
        }

        if (headerRowIndex === -1) {
          console.error(
            "parseOrgStructure: Could not find a valid header row!"
          );
          return {};
        }

        const headers = rows[headerRowIndex];
        console.log("parseOrgStructure: Extracted headers:", headers);

        // **HEADER VALIDATION AND NORMALIZATION**
        if (!headers || headers.length === 0) {
          console.error("parseOrgStructure: Header row is empty or invalid!");
          return {};
        }

        const normalizedHeaders = headers.map((header) => {
          if (typeof header === "string") {
            return header.trim().toLowerCase();
          } else {
            console.warn("parseOrgStructure: Skipping invalid header:", header);
            return null;
          }
        });

        console.log(
          "parseOrgStructure: Normalized headers:",
          normalizedHeaders
        );

        const idIndex = normalizedHeaders.indexOf("id");
        const parentIdIndex = normalizedHeaders.indexOf("parent_id");
        const nameIndex = normalizedHeaders.indexOf("name");
        const levelIndex = normalizedHeaders.indexOf("level");

        if (idIndex === -1 || parentIdIndex === -1 || nameIndex === -1) {
          console.error(
            "parseOrgStructure: Missing required columns (ID, Parent_ID, Name) in sheet headers!"
          );
          return {};
        }

        const orgStructure = {};

        // **PROCESS DATA ROWS**
        rows.slice(headerRowIndex + 1).forEach((row) => {
          const id = row[idIndex] ? String(row[idIndex]).trim() : null;
          const parentId = row[parentIdIndex]
            ? String(row[parentIdIndex]).trim()
            : null;
          const name = row[nameIndex] ? String(row[nameIndex]).trim() : null;
          const level = row[levelIndex]
            ? parseInt(row[levelIndex], 10) || 0
            : 0;

          if (!id) {
            console.warn(
              "parseOrgStructure: Skipping row with missing ID:",
              row
            );
            return;
          }

          orgStructure[id] = {
            id,
            level,
            name,
            parentId,
            children: [],
          };

          // console.log(`parseOrgStructure: Added org unit with ID=${id}, Parent_ID=${parentId}`);
        });

        // **LINK CHILDREN TO PARENTS**
        Object.keys(orgStructure).forEach((id) => {
          const unit = orgStructure[id];
          if (unit.parentId && orgStructure[unit.parentId]) {
            orgStructure[unit.parentId].children.push(unit);
          }
        });

        console.log("parseOrgStructure: Parsed orgStructure:", orgStructure);

        // **VERIFY ROOT NODE**
        if (!orgStructure["1"] || !orgStructure["1"].name) {
          console.error(
            "parseOrgStructure: Root node (ID=1) is undefined or missing a Name!"
          );
        } else {
          console.log("parseOrgStructure: Root node:", orgStructure["1"]);
          console.log(
            "Org Unit IDs in Org Structure:",
            Object.keys(orgStructure)
          );
        }

        // Add this after building the hierarchy:
        if (orgStructure["1"]) {
          orgStructure.organization =
            orgStructure["1"].name || "Enterprise Operations";
          orgStructure.abbreviation = orgStructure["1"].abbreviation || "EOps";
        }

        return orgStructure;
      } // eof parseOrgStructure

      function parseRisks(sheet, orgStructure) {
        console.log("parseRisks: Starting risk parsing...");

        if (!sheet) {
          console.error("parseRisks: Risks sheet is missing!");
          return [];
        }

        // Convert the sheet into rows
        const rows = XLSX.utils.sheet_to_json(sheet, {
          defval: null,
          header: 1, // Read as raw rows
        });

        console.log("parseRisks: Raw rows from sheet:", rows);

        // Extract and validate headers
        const headers = rows[0];
        if (!headers || headers.length === 0) {
          console.error("parseRisks: Header row is empty or missing!");
          return [];
        }

        // Normalize headers
        const normalizedHeaders = headers.map((header) => {
          if (typeof header === "string") {
            return header.trim().toLowerCase();
          } else {
            console.warn("parseRisks: Skipping invalid header:", header);
            return null;
          }
        });

        // Map column names to their indexes
        const orgUnitIdIndex = normalizedHeaders.indexOf("org_unit_id");
        const riskIdIndex = normalizedHeaders.indexOf("risk_id");
        const titleIndex = normalizedHeaders.indexOf("title");
        const descriptionIndex = normalizedHeaders.indexOf("description");
        const typeIndex = normalizedHeaders.indexOf("type");
        const categoryIndex = normalizedHeaders.indexOf("category");
        const ownerIndex = normalizedHeaders.indexOf("owner");
        const levelIndex = normalizedHeaders.indexOf("level");
        const priorityIndex = normalizedHeaders.indexOf("priority");
        const velocityIndex = normalizedHeaders.indexOf("velocity");
        const magnitudeIndex = normalizedHeaders.indexOf("magnitude");
        const assetIdIndex = normalizedHeaders.indexOf("asset_id");
        const mitigationPlanIndex =
          normalizedHeaders.indexOf("mitigation_plan");

        // Validate required columns
        if (orgUnitIdIndex === -1 || riskIdIndex === -1 || titleIndex === -1) {
          console.error(
            "parseRisks: Missing required columns in sheet headers!"
          );
          return [];
        }

        const risks = []; // Final risks array

        // Process each row (skip the header row)
        rows.slice(1).forEach((row) => {
          const orgUnitId = row[orgUnitIdIndex];
          if (!orgUnitId || !orgStructure[orgUnitId]) {
            console.warn(
              "parseRisks: Skipping row with missing or invalid Org_Unit_ID:",
              row
            );
            return;
          }

          // Extract all relevant fields
          const riskId = row[riskIdIndex];
          const title = row[titleIndex];
          const description =
            descriptionIndex !== -1 ? row[descriptionIndex] || "" : "";
          const type = typeIndex !== -1 ? row[typeIndex] || "" : "";
          const category = categoryIndex !== -1 ? row[categoryIndex] || "" : "";
          const owner = ownerIndex !== -1 ? row[ownerIndex] || "" : "";
          const level = levelIndex !== -1 ? row[levelIndex] || "" : "";
          const priority = priorityIndex !== -1 ? row[priorityIndex] || "" : "";
          const velocity = velocityIndex !== -1 ? row[velocityIndex] || "" : "";
          const magnitude =
            magnitudeIndex !== -1 ? row[magnitudeIndex] || "" : "";
          const assetId = assetIdIndex !== -1 ? row[assetIdIndex] || "" : "";
          const mitigationPlan =
            mitigationPlanIndex !== -1 ? row[mitigationPlanIndex] || "" : "";

          // Construct the risk object
          const risk = {
            riskId,
            title,
            description,
            type,
            category,
            owner,
            level,
            priority,
            velocity,
            magnitude,
            assetId,
            mitigationPlan,
            orgUnitId: String(orgUnitId),
          };

          console.log(
            `parseRisks: Assigning risk ${risk.riskId} to Org Unit ID ${orgUnitId}`
          );
          // Add the risk to the array
          risks.push(risk);
        });

        console.log("parseRisks: Final risks array:", risks);
        console.log(
          "Org Unit IDs in Risks:",
          risks.map((risk) => risk.orgUnitId)
        );
        return risks;
      } // end of parseRisks

      function parseAssets(sheet, orgStructure) {
        // 1. Convert sheet to JSON with YOUR exact column headers
        const assetRows = XLSX.utils.sheet_to_json(sheet, {
          defval: null,
          header: ["Asset_ID", "Asset_name", "Org_Unit_ID", "Asset_value"], // Matches your Excel
          range: 1, // Skip header row
        });

        // 2. Process each row with proper field mapping
        return assetRows.reduce((assets, row) => {
          try {
            // Required fields validation
            if (!row.Asset_ID || !row.Org_Unit_ID || !row.Asset_name) {
              console.warn("Skipping incomplete asset row:", row);
              return assets;
            }

            // Verify org unit exists
            const orgUnitId = String(row.Org_Unit_ID).trim();
            if (!orgStructure[orgUnitId]) {
              console.warn(
                `Skipping asset - invalid Org_Unit_ID: ${orgUnitId}`
              );
              return assets;
            }

            assets.push({
              id: String(row.Asset_ID).trim(),
              name: String(row.Asset_name).trim(),
              value: parseFloat(String(row.Asset_value).replace(/,/g, "")), // Handle currency format
              orgUnitId: orgUnitId,
            });
          } catch (error) {
            console.error("Error processing asset row:", row, error);
          }
          return assets;
        }, []);
      } // eof parseAssets

      function processExcelWorkbook(workbook) {
        console.log("processExcelWorkbook: Starting workbook processing...");

        // Retrieve all sheet names dynamically
        const sheetNames = workbook.SheetNames;
        console.log("processExcelWorkbook: Available sheet names:", sheetNames);

        // Initialize placeholders for the sheets we need
        let assetSheet = null;
        let orgSheet = null;
        let risksSheet = null;

        // Match sheet names dynamically
        sheetNames.forEach((sheetName) => {
          const lowerName = sheetName.toLowerCase().trim(); // Normalize for comparison

          if (lowerName.includes("asset")) {
            assetSheet = workbook.Sheets[sheetName];
            console.log(
              `processExcelWorkbook: Found Asset sheet: ${sheetName}`
            );
          } else if (
            lowerName.includes("org structure") ||
            lowerName.includes("organization")
          ) {
            orgSheet = workbook.Sheets[sheetName];
            console.log(
              `processExcelWorkbook: Found Org Structure sheet: ${sheetName}`
            );
          } else if (lowerName.includes("risk")) {
            risksSheet = workbook.Sheets[sheetName];
            console.log(
              `processExcelWorkbook: Found Risks sheet: ${sheetName}`
            );
          }
        });

        // Check if all required sheets were found
        if (!assetSheet) {
          console.error("processExcelWorkbook: Asset sheet not found!");
        }
        if (!orgSheet) {
          console.error("processExcelWorkbook: Org Structure sheet not found!");
        }
        if (!risksSheet) {
          console.error("processExcelWorkbook: Risks sheet not found!");
        }

        // If any sheet is missing, stop further processing
        if (!assetSheet || !orgSheet || !risksSheet) {
          console.error(
            "processExcelWorkbook: One or more required sheets are missing. Stopping processing."
          );
          return;
        }

        // Parse assets data
        const assetsData = XLSX.utils.sheet_to_json(assetSheet, {
          defval: null,
        });
        console.log("processExcelWorkbook: Raw assets data:", assetsData);

        // Parse organization structure
        const orgStructure = parseOrgStructure(orgSheet);
        console.log(
          "processExcelWorkbook: Parsed Organizational Structure:",
          orgStructure
        );

        // Parse risks data
        const risksData = XLSX.utils.sheet_to_json(risksSheet, {
          defval: null,
        });
        console.log("processExcelWorkbook: Raw Risks data:", risksData);

        const risks = parseRisks(risksSheet, orgStructure);
        console.log("processExcelWorkbook: Parsed Risks:", risks);

        // Return the processed data
        return {
          assets: assetsData,
          orgStructure,
          risks,
        };
      }

      // Switch to the data for a specific time index
      function switchToTimeIndex(timeIndex) {
        try {
          if (!timeIndexedData[timeIndex]) {
            debugLog(`No data for timeIndex ${timeIndex}`);
            return false;
          }

          // Update both legacy and new state during transition
          data = timeIndexedData[timeIndex]; // Legacy compatibility
          AppState.current = {
            ...timeIndexedData[timeIndex],
            timeIndex,
            orgLevel: parseInt(orgSlider?.value || 0), // Maintain UI sync
          };

          debugLog("Switched to time index", timeIndex, {
            risks: AppState.current.risks?.length,
            org: AppState.current.orgStructure?.organization,
          });

          updateTimeLabel(timeIndex);
          updateDataStatus(timeIndex);

          return true;
        } catch (error) {
          debugLog("Switch failed:", error, { timeIndex, timeIndexedData });
          return false;
        }
      }

      // Extracted helper
      function updateTimeLabel(timeIndex) {
        if (!timeLabel) return;

        const labels = {
          0: "4 weeks ago",
          1: "3 weeks ago",
          2: "2 weeks ago",
          3: "1 week ago",
          4: "Current",
        };
        timeLabel.textContent = labels[timeIndex] || `Time ${timeIndex}`;
      }

      // Load data for a specific time index and update the visualization
      async function loadDataForTimeIndex(timeIndex) {
        try {
          // Check if we already have data for this index
          if (timeIndexedData[timeIndex]) {
            // Use existing data
            switchToTimeIndex(timeIndex);
            return true;
          }

          // Try to load the Excel file
          const workbook = await loadExcelFile(timeIndex);
          if (workbook) {
            console.log(
              `loadDataForTimeIndex: Loaded timeIndex ${timeIndex} data:`,
              timeIndexedData[timeIndex]
            );
            // Process the workbook and store the data
            const processedData = processExcelWorkbook(workbook);
            timeIndexedData[timeIndex] = processedData;

            // Switch to this data
            switchToTimeIndex(timeIndex);
            return true;
          }
          return false;
        } catch (error) {
          console.error(
            `Error loading data for time index ${timeIndex}:`,
            error
          );
          /*
          const dataStatus = document.getElementById("data-status");
          if (dataStatus) {
            dataStatus.textContent = `Error loading data: ${error.message}`;
          }
          */
          showLoading(false);
          return false;
        }
      } // eof loadDataForTimeIndex

      // Initialize data
      // const data = generateRisksData();
      // Replace original `data = generateRisksData()` with:
      /*
      async function initializeData() {
        showLoading(true);
        try {
          // 1. Load current week first
          await loadDataForTimeIndex(4);

          // 2. Set up lazy loading for others
          setupLazyLoading();

          // 3. Initialize UI
          setOrgLevel(0);
        } finally {
          showLoading(false);
        }
      } // eof initializeData
      */

      // New lazy loading handler
      function setupLazyLoading() {
        // Load adjacent weeks when idle
        const loadAdjacentWeeks = debounce(() => {
          const current = parseInt(timeSlider.value);
          [current - 1, current + 1].forEach((t) => {
            if (t >= 0 && t <= 4 && !timeIndexedData[t]) {
              loadDataForTimeIndex(t);
            }
          });
        }, 500);

        // Trigger on slider movement
        timeSlider.addEventListener("input", loadAdjacentWeeks);

        // Simple debounce helper
        function debounce(fn, delay) {
          let timeout;
          return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => fn(...args), delay);
          };
        }
      }

      /*
      async function loadWeekData(timeIndex) {
        const filename = weekFiles[timeIndex];
        if (!filename) {
          debugLog(
            `loadWeekData: No filename mapped for timeIndex ${timeIndex}`
          );
          throw new Error(`loadWeekData: Invalid time index: ${timeIndex}`);
        }

        try {
          showLoading(true);
          debugLog(`loadWeekData: Loading week ${timeIndex} from ${filename}`);

          // 1. Fetch and parse Excel file
          const response = await fetch(`./data/${filename}`);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status} loading ${filename}`);
          }

          const arrayBuffer = await response.arrayBuffer();
          const workbook = XLSX.read(new Uint8Array(arrayBuffer), {
            type: "array",
          });

          // 2. Process sheets with validation
          const assetsSheet = workbook.Sheets["Assets"];
          const orgSheet = workbook.Sheets["Org Structure"];
          const risksSheet = workbook.Sheets["Risks"];

          if (!orgSheet || !risksSheet) {
            throw new Error(`Missing required sheets in ${filename}`);
          }

          // 3. Parse data
          const orgStructure = parseOrgStructure(orgSheet);
          const risks = parseRisks(risksSheet, orgStructure);
          const assets = parseAssets(assetsSheet, orgStructure);

          debugLog(`Loaded week ${timeIndex}`, {
            riskCount: risks.length,
            assetCount: assets.length,
            orgUnits: Object.keys(orgStructure).length,
          });

          return {
            assets: assets,
            orgStructure: orgStructure,
            risks: risks,
          };
        } catch (error) {
          console.error(
            `loadWeekData: failed for timeIndex ${timeIndex}:`,
            error
          );
          return null; // Explicit null instead of undefined
        }
      } */

      async function loadWeekData(timeIndex) {
        try {
          // 1. Load raw Excel file
          const workbook = await loadExcelFile(timeIndex);
          if (!workbook) throw new Error("No workbook returned");

          // 2. Extract sheets (with validation)
          const assetsSheet = workbook.Sheets["Assets"];
          const orgSheet = workbook.Sheets["Org Structure"];
          const risksSheet = workbook.Sheets["Risks"];

          if (!orgSheet || !risksSheet) {
            throw new Error("Missing required sheets in workbook");
          }

          // 3. Process data
          const orgStructure = parseOrgStructure(orgSheet);
          const risks = parseRisks(risksSheet, orgStructure);
          const assets = assetsSheet
            ? parseAssets(assetsSheet, orgStructure)
            : [];

          // 4. Update state systems
          const processedData = {
            assets,
            orgStructure,
            risks,
          };

          timeIndexedData[timeIndex] = processedData;
          AppState.current = {
            ...processedData,
            timeIndex,
            orgLevel: parseInt(orgSlider?.value || 0),
          };

          debugLog(`Loaded week ${timeIndex}`, {
            risks: risks.length,
            assets: assets.length,
            orgUnits: Object.keys(orgStructure).length,
          });

          return processedData;
        } catch (error) {
          console.error(`loadWeekData(${timeIndex}) failed:`, error);
          throw error;
        }
      } // eof loadWeekData

      // Proposed (more accurate naming)
      async function initRiskVisualization() {
        try {
          // Load current week (timeIndex 4)
          AppState.timeIndexedData[4] = await loadWeekData(4);

          if (!AppState.timeIndexedData[4]) {
            throw new Error("Failed to load initial week data");
          }

          // Initialize state
          AppState.current = {
            ...AppState.timeIndexedData[4],
            timeIndex: 4,
            orgLevel: 0,
          };

          // UI setup
          orgSlider.value = 0;
          timeSlider.value = 4;

          debugLog("Initialization complete", AppState.current);
        } catch (error) {
          console.error("Initialization failed:", error);
          document.getElementById(
            "data-status"
          ).textContent = `Error: ${error.message}`;
        } finally {
          showLoading(false);
        }
      }

      // Call this instead of `generateRisksData()`
      initRiskVisualization().then(() => updateAquarium());

      const aquarium = document.getElementById("aquarium");
      const tooltip = document.getElementById("tooltip");
      const timeSlider = document.getElementById("time-slider");
      const timeLabel = document.getElementById("time-label");
      const orgSlider = document.getElementById("org-slider");
      const orgLevelIndicator = document.getElementById("org-level-indicator");
      const bubblesContainer = document.getElementById("bubbles");

      // Get color based on priority
      function getPriorityColor(priority) {
        switch (Math.round(priority)) {
          case 1:
            return "var(--priority-1-color)";
          case 2:
            return "var(--priority-2-color)";
          case 3:
            return "var(--priority-3-color)";
          case 4:
            return "var(--priority-4-color)";
          case 5:
            return "var(--priority-5-color)";
          default:
            return "var(--priority-3-color)";
        }
      }

      // Create risk bubble element
      function createRiskBubbleElement(risk, timeIndex) {
        const timeData = risk.timeData[timeIndex];
        const priority = timeData.priority;
        const velocity = timeData.velocity;
        const magnitude = timeData.magnitude;

        const bubbleElement = document.createElement("div");
        bubbleElement.classList.add("risk-bubble");
        bubbleElement.dataset.id = risk.id;

        // Set size based on magnitude (1-5)
        const baseSize = 40; // base size in pixels
        const size = baseSize + (magnitude - 1) * 15; // scale size based on magnitude
        bubbleElement.style.width = `${size}px`;
        bubbleElement.style.height = `${size}px`;

        // Set position based on priority (vertical) and velocity (horizontal)
        // Higher priority bubbles should be higher in the aquarium
        // Higher velocity bubbles should be more to the right

        // Create vertical position based on priority (5 = highest, 1 = lowest)
        // Add some randomness to prevent exact alignment
        const verticalPosition = 85 - ((priority - 1) * 15 + Math.random() * 5);
        bubbleElement.style.top = `${verticalPosition}%`;

        // Create horizontal position based on velocity (3 = rightmost, 1 = leftmost)
        // Add some randomness to prevent exact alignment
        const horizontalPosition = (velocity - 1) * 30 + Math.random() * 10;
        bubbleElement.style.left = `${horizontalPosition}%`;

        // Set color based on priority
        const color = getPriorityColor(priority);
        bubbleElement.style.backgroundColor = color;

        // Add risk ID
        const riskId = document.createElement("div");
        riskId.classList.add("fish-id"); // Keeping the class name for simplicity
        riskId.textContent = risk.id;
        bubbleElement.appendChild(riskId);

        // Add subtle animation to make bubble "float" slightly
        bubbleElement.animate(
          [
            { transform: "translate(0, 0) scale(1)" },
            {
              transform: `translate(${
                Math.random() > 0.5 ? 5 : -5
              }px, -5px) scale(1.03)`,
            },
            { transform: "translate(0, 0) scale(1)" },
          ],
          {
            duration: 3000 + Math.random() * 2000,
            iterations: Infinity,
            easing: "ease-in-out",
          }
        );

        // Add tooltip on hover
        bubbleElement.addEventListener("mouseenter", (e) => {
          tooltip.innerHTML = `
                    <strong>${risk.id}</strong><br>
                    Magnitude: ${magnitude.toFixed(1)}<br>
                    Priority: P${Math.round(priority)}<br>
                    Velocity: V${Math.round(velocity)}
                `;

          const rect = bubbleElement.getBoundingClientRect();
          tooltip.style.left = `${rect.left + rect.width / 2}px`;
          tooltip.style.top = `${rect.top}px`;
          tooltip.style.opacity = "1";
        });

        bubbleElement.addEventListener("mouseleave", () => {
          tooltip.style.opacity = "0";
        });

        // Add click to show details popup
        bubbleElement.addEventListener("click", () => {
          showRiskDetails(risk, timeIndex);
        });

        return bubbleElement;
      }

      // Create decorative bubbles
      function createBubbles() {
        bubblesContainer.innerHTML = "";
        const bubbleCount = 15;

        for (let i = 0; i < bubbleCount; i++) {
          const bubble = document.createElement("div");
          bubble.classList.add("bubble");

          // Random size between 5px and 20px
          const size = 5 + Math.random() * 15;
          bubble.style.width = `${size}px`;
          bubble.style.height = `${size}px`;

          // Random horizontal position
          const left = Math.random() * 100;
          bubble.style.left = `${left}%`;

          // Random start position vertically (some below the viewport)
          const bottom = -20 + Math.random() * 100;
          bubble.style.bottom = `${bottom}%`;

          // Random animation duration between 10s and 30s
          const duration = 10 + Math.random() * 20;
          bubble.style.animationDuration = `${duration}s`;

          // Random delay so they don't all start at the same time
          const delay = Math.random() * 15;
          bubble.style.animationDelay = `${delay}s`;

          bubblesContainer.appendChild(bubble);
        }
      }

      // Show risk details in popup
      function showRiskDetails(risk, timeIndex) {
        // Remove existing popup if any
        const existingPopup = document.querySelector(".popup");
        const existingBackdrop = document.querySelector(".backdrop");

        if (existingPopup) {
          existingPopup.remove();
        }

        if (existingBackdrop) {
          existingBackdrop.remove();
        }

        // Create backdrop
        const backdrop = document.createElement("div");
        backdrop.classList.add("backdrop");
        document.body.appendChild(backdrop);

        // Create popup
        const popup = document.createElement("div");
        popup.classList.add("popup");

        const timeData = risk.timeData[timeIndex];
        const priority = timeData.priority;
        const velocity = timeData.velocity;
        const magnitude = timeData.magnitude;

        // Create popup content - revised for better visibility
        popup.innerHTML = `
                <div class="popup-content">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold">${risk.id}: ${
          risk.title
        }</h2>
                        <button class="close-popup text-gray-500 hover:text-gray-700">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                    
                    <div>
                        <p class="mb-2"><strong>Description:</strong> ${
                          risk.description
                        }</p>
                        <p class="mb-2"><strong>Category:</strong> ${
                          risk.category
                        }</p>
                        <p class="mb-2"><strong>Owner:</strong> ${
                          risk.owner
                        }</p>
                        <p class="mb-2"><strong>Organization Level:</strong> ${
                          risk.level
                        } (${risk.entity})</p>
                        <p class="mb-2"><strong>Mitigation Plan:</strong> ${
                          risk.mitigationPlan
                        }</p>
                    </div>
                    
                    <!-- Metrics display without scrolling -->
                    <div class="risk-metrics mt-4">
                        <div class="metric-card" style="border-left: 4px solid ${getPriorityColor(
                          priority
                        )};">
                            <div class="metric-label">Priority</div>
                            <div class="metric-value">P${Math.round(
                              priority
                            )}</div>
                            <div class="metric-label">${
                              [
                                "Very Low",
                                "Low",
                                "Medium",
                                "High",
                                "Very High",
                              ][Math.round(priority) - 1]
                            }</div>
                        </div>
                        
                        <div class="metric-card" style="border-left: 4px solid var(--velocity-${Math.round(
                          velocity
                        )}-color);">
                            <div class="metric-label">Velocity</div>
                            <div class="metric-value">V${Math.round(
                              velocity
                            )}</div>
                            <div class="metric-label">${
                              ["Slow", "Medium", "Fast"][
                                Math.round(velocity) - 1
                              ]
                            }</div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-label">Magnitude</div>
                            <div class="metric-value">${magnitude.toFixed(
                              1
                            )}</div>
                            <div class="metric-label">${
                              [
                                "Very Low",
                                "Low",
                                "Medium",
                                "High",
                                "Very High",
                              ][Math.round(magnitude) - 1]
                            }</div>
                        </div>
                    </div>
                    
                    <div class="mt-4">
                        <h3 class="font-medium mb-2">Historical Trend</h3>
                        <div class="trend-container">
                            <canvas id="trendChart"></canvas>
                        </div>
                    </div>
                </div>
            `;

        document.body.appendChild(popup);

        // Close popup when clicking the close button
        const closeButton = popup.querySelector(".close-popup");
        closeButton.addEventListener("click", () => {
          popup.remove();
          backdrop.remove();
        });

        // Close popup when clicking backdrop
        backdrop.addEventListener("click", () => {
          popup.remove();
          backdrop.remove();
        });

        // Close popup when pressing Escape key
        document.addEventListener("keydown", function closeOnEscape(e) {
          if (e.key === "Escape") {
            popup.remove();
            backdrop.remove();
            document.removeEventListener("keydown", closeOnEscape);
          }
        });

        // Create trend chart with fixed height
        const ctx = document.getElementById("trendChart").getContext("2d");
        new Chart(ctx, {
          type: "line",
          data: {
            labels: [
              "4 weeks ago",
              "3 weeks ago",
              "2 weeks ago",
              "1 week ago",
              "Current",
            ],
            datasets: [
              {
                label: "Priority",
                data: risk.timeData.map((d) => d.priority),
                borderColor: "rgb(255, 99, 132)",
                backgroundColor: "rgba(255, 99, 132, 0.2)",
                fill: false,
                tension: 0.1,
              },
              {
                label: "Velocity",
                data: risk.timeData.map((d) => d.velocity),
                borderColor: "rgb(54, 162, 235)",
                backgroundColor: "rgba(54, 162, 235, 0.2)",
                fill: false,
                tension: 0.1,
              },
              {
                label: "Magnitude",
                data: risk.timeData.map((d) => d.magnitude),
                borderColor: "rgb(255, 159, 64)",
                backgroundColor: "rgba(255, 159, 64, 0.2)",
                fill: false,
                tension: 0.1,
              },
            ],
          },
          options: {
            scales: {
              y: {
                beginAtZero: false,
                min: 1,
                max: 5,
                ticks: {
                  stepSize: 1,
                },
              },
            },
            responsive: true,
            maintainAspectRatio: false,
          },
        });
      }

      /* Calculate aggregated risk metrics for an organization entity
      function calculateAggregatedRiskMetrics(
        entityType,
        entityName,
        parentEntityName,
        timeIndex
      ) {
        // Add guard clause
        if (!timeIndexedData[timeIndex]?.risks) {
          console.error(
            `calculateAggregatedRiskMetrics: No data for timeIndex ${timeIndex}`,
            timeIndexedData
          );
          return { priority: 1, velocity: 1, magnitude: 1, count: 0 };
        }

        let entityRisks = [];

        // IMPROVED IMPLEMENTATION: Get all relevant risks for each entity level
        // This takes into account risks from child organizational units
        if (entityType === "organization") {
          // For the main organization, include ALL risks across all levels
          // This reflects the total risk exposure for the entire organization
          entityRisks = data.risks;
        } else if (entityType === "division") {
          // For divisions, include:
          // 1. Division-level risks for this division
          // 2. All department-level risks under this division
          // 3. All BU-level risks under this division
          entityRisks = data.risks.filter(
            (risk) =>
              (risk.level === "division" && risk.entity === entityName) ||
              (risk.level === "department" &&
                risk.parentEntity === entityName) ||
              (risk.level === "businessUnit" &&
                risk.grandparentEntity === entityName)
          );
        } else if (entityType === "department") {
          // For departments, include:
          // 1. Department-level risks for this department
          // 2. All BU-level risks under this department
          entityRisks = data.risks.filter(
            (risk) =>
              (risk.level === "department" &&
                risk.entity === entityName &&
                risk.parentEntity === parentEntityName) ||
              (risk.level === "businessUnit" &&
                risk.parentEntity === entityName &&
                risk.grandparentEntity === parentEntityName)
          );
        } else if (entityType === "businessUnit") {
          // For BUs, include only BU-level risks for this BU (no change from original)
          entityRisks = data.risks.filter(
            (risk) =>
              risk.level === "businessUnit" && risk.entity === entityName
          );
        }

        // If no risks found, return default values
        if (entityRisks.length === 0) {
          return {
            priority: 1,
            velocity: 1,
            magnitude: 1,
            count: 0,
          };
        }

        // Calculate aggregated metrics
        let totalPriority = 0;
        let totalVelocity = 0;
        let totalMagnitude = 0;

        entityRisks.forEach((risk) => {
          const timeData = risk.timeData[timeIndex];
          totalPriority += timeData.priority;
          totalVelocity += timeData.velocity;
          totalMagnitude += timeData.magnitude;
        });

        // Return average values, weighted by risk count
        return {
          priority: totalPriority / entityRisks.length,
          velocity: totalVelocity / entityRisks.length,
          magnitude: totalMagnitude / entityRisks.length,
          count: entityRisks.length,
        };
      }
      */

      // Helper to filter risks (extracted for clarity)
      function getRelevantRisks(entityType, entityName, parentEntityName) {
        if (!data?.risks) return [];

        return AppState.current.risks.filter((risk) => {
          switch (entityType) {
            case "organization":
              return (
                risk.level === "organization" && risk.entity === entityName
              );

            case "division":
              return (
                (risk.level === "division" && risk.entity === entityName) ||
                (risk.level === "department" &&
                  risk.parentEntity === entityName) ||
                (risk.level === "businessUnit" &&
                  risk.grandparentEntity === entityName)
              );

            case "department":
              return (
                (risk.level === "department" &&
                  risk.entity === entityName &&
                  risk.parentEntity === parentEntityName) ||
                (risk.level === "businessUnit" &&
                  risk.parentEntity === entityName &&
                  risk.grandparentEntity === parentEntityName)
              );

            case "businessUnit":
              return (
                risk.level === "businessUnit" && risk.entity === entityName
              );

            default:
              return false;
          }
        });
      }

      function calculateAggregatedRiskMetrics(
        entityType,
        entityName,
        parentEntityName,
        timeIndex
      ) {
        const entityRisks = getRelevantRisks(
          entityType,
          entityName,
          parentEntityName
        );

        if (!entityRisks.length) {
          return { priority: 1, velocity: 1, magnitude: 1, count: 0 };
        }

        let totalPriority = 0;
        let totalVelocity = 0;
        let totalMagnitude = 0;

        entityRisks.forEach((risk) => {
          // Handle both timeData and flat formats
          const metrics = risk.timeData?.[timeIndex] || {
            priority: risk.priority,
            velocity: risk.velocity,
            magnitude: risk.magnitude,
          };

          totalPriority += metrics.priority;
          totalVelocity += metrics.velocity;
          totalMagnitude += metrics.magnitude;
        });

        return {
          priority: totalPriority / entityRisks.length,
          velocity: totalVelocity / entityRisks.length,
          magnitude: totalMagnitude / entityRisks.length,
          count: entityRisks.length,
        };
      }

      // Create an entity bubble (org, division, department, or BU)
      function createEntityBubble(
        entityType,
        entityName,
        parentEntityName,
        grandparentEntityName,
        metrics,
        timeIndex
      ) {
        const orgStructure = AppState.current.orgStructure;
        const displayName =
          entityName ||
          (entityType === "organization"
            ? orgStructure.abbreviation || orgStructure.organization
            : "Unnamed Entity");

        const bubble = document.createElement("div");
        bubble.classList.add("risk-bubble");

        // Check if entity has no risks and apply appropriate styling
        // This creates a semi-transparent appearance with dashed border for zero-risk entities
        const hasNoRisks = metrics.count === 0;
        if (hasNoRisks) {
          bubble.classList.add("no-risks");
        }

        // Set size based on magnitude and number of risks
        const baseSize = 50;
        const size = hasNoRisks
          ? baseSize
          : baseSize +
            (metrics.magnitude - 1) * 10 +
            Math.min(metrics.count * 3, 30);
        bubble.style.width = `${size}px`;
        bubble.style.height = `${size}px`;

        // Set position based on priority and velocity (use defaults if no risks)
        const verticalPosition = hasNoRisks
          ? 50 + Math.random() * 20 // Position in middle area with some randomness
          : 85 - ((metrics.priority - 1) * 15 + Math.random() * 5);
        bubble.style.top = `${verticalPosition}%`;

        const horizontalPosition = hasNoRisks
          ? 10 + Math.random() * 70 // Position horizontally with randomness
          : (metrics.velocity - 1) * 30 + Math.random() * 10;
        bubble.style.left = `${horizontalPosition}%`;

        // Set color based on priority (default gray for no risks)
        const color = hasNoRisks
          ? "#888888"
          : getPriorityColor(metrics.priority);
        bubble.style.backgroundColor = color;

        // Add entity name
        const nameElement = document.createElement("div");
        nameElement.classList.add("fish-id");
        nameElement.textContent =
          displayName.length > 15
            ? displayName.substring(0, 12) + "..."
            : displayName;

        bubble.appendChild(nameElement);

        // Add tooltip on hover
        bubble.addEventListener("mouseenter", () => {
          if (hasNoRisks) {
            tooltip.innerHTML = `
                        <strong>${entityName}</strong><br>
                        No risks associated with this ${entityType}
                    `;
          } else {
            tooltip.innerHTML = `
                        <strong>${entityName}</strong><br>
                        ${metrics.count} Risk${
              metrics.count !== 1 ? "s" : ""
            }<br>
                        Avg. Magnitude: ${metrics.magnitude.toFixed(1)}<br>
                        Avg. Priority: ${metrics.priority.toFixed(1)}<br>
                        Avg. Velocity: ${metrics.velocity.toFixed(1)}
                    `;
          }

          const rect = bubble.getBoundingClientRect();
          tooltip.style.left = `${rect.left + rect.width / 2}px`;
          tooltip.style.top = `${rect.top}px`;
          tooltip.style.opacity = "1";
        });

        bubble.addEventListener("mouseleave", () => {
          tooltip.style.opacity = "0";
        });

        // Add subtle animation
        bubble.animate(
          [
            { transform: "translate(0, 0) scale(1)" },
            {
              transform: `translate(${
                Math.random() > 0.5 ? 5 : -5
              }px, -5px) scale(1.03)`,
            },
            { transform: "translate(0, 0) scale(1)" },
          ],
          {
            duration: 3000 + Math.random() * 2000,
            iterations: Infinity,
            easing: "ease-in-out",
          }
        );

        // Add click handler for drill-down if applicable
        bubble.addEventListener("click", () => {
          if (entityType === "organization") {
            // When clicking the organization, show all divisions
            setOrgLevel(1);
          } else if (entityType === "division") {
            // When clicking a division, filter to show only departments in that division
            selectedDivision = entityName;
            setOrgLevel(2);
          } else if (entityType === "department") {
            // When clicking a department, filter to show only BUs in that department
            selectedDepartment = entityName;
            selectedDivision = parentEntityName;
            setOrgLevel(3);
          } else {
            // For BUs, show detailed risk data in a popup
            showEntityDetails(
              entityType,
              entityName,
              parentEntityName,
              grandparentEntityName,
              metrics,
              timeIndex
            );
          }
        });

        return bubble;
      }

      // Show entity details in a popup
      function showEntityDetails(
        entityType,
        entityName,
        parentEntityName,
        grandparentEntityName,
        metrics,
        timeIndex
      ) {
        // Remove existing popup if any
        const existingPopup = document.querySelector(".popup");
        const existingBackdrop = document.querySelector(".backdrop");

        if (existingPopup) {
          existingPopup.remove();
        }

        if (existingBackdrop) {
          existingBackdrop.remove();
        }

        // Create backdrop
        const backdrop = document.createElement("div");
        backdrop.classList.add("backdrop");
        document.body.appendChild(backdrop);

        // Create popup
        const popup = document.createElement("div");
        popup.classList.add("popup");

        // Get risks for this entity - this should match the logic from calculateAggregatedRiskMetrics
        let entityRisks = [];
        if (entityType === "organization") {
          // For the organization view, show all risks from all levels
          entityRisks = AppState.current.risks;
        } else if (entityType === "division") {
          // For divisions, show all risks from this division and below
          entityRisks = AppState.current.risks.filter(
            (risk) =>
              (risk.level === "division" && risk.entity === entityName) ||
              (risk.level === "department" &&
                risk.parentEntity === entityName) ||
              (risk.level === "businessUnit" &&
                risk.grandparentEntity === entityName)
          );
        } else if (entityType === "department") {
          // For departments, show all risks from this department and below
          entityRisks = AppState.current.risks.filter(
            (risk) =>
              (risk.level === "department" &&
                risk.entity === entityName &&
                risk.parentEntity === parentEntityName) ||
              (risk.level === "businessUnit" &&
                risk.parentEntity === entityName &&
                risk.grandparentEntity === parentEntityName)
          );
        } else if (entityType === "businessUnit") {
          // For BUs, show only this BU's risks
          entityRisks = AppState.current.risks.filter(
            (risk) =>
              risk.level === "businessUnit" && risk.entity === entityName
          );
        }

        // Create popup content
        let hierarchyText = entityName;
        if (parentEntityName) hierarchyText += ` in ${parentEntityName}`;
        if (grandparentEntityName)
          hierarchyText += `, ${grandparentEntityName}`;

        // For entities with no risks, show a special message
        const hasNoRisks = entityRisks.length === 0;

        popup.innerHTML = `
                <div class="popup-content">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold">${
                          entityType.charAt(0).toUpperCase() +
                          entityType.slice(1)
                        }: ${hierarchyText}</h2>
                        <button class="close-popup text-gray-500 hover:text-gray-700">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                    
                    ${
                      hasNoRisks
                        ? `
                        <div class="p-6 text-center">
                            <div class="mb-4 text-gray-500 dark:text-gray-400">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                <p class="text-lg">No risks are currently associated with this ${entityType}.</p>
                            </div>
                        </div>
                    `
                        : `
                        <div class="risk-metrics mb-4">
                            <div class="metric-card" style="border-left: 4px solid ${getPriorityColor(
                              metrics.priority
                            )};">
                                <div class="metric-label">Avg Priority</div>
                                <div class="metric-value">${metrics.priority.toFixed(
                                  1
                                )}</div>
                            </div>
                            
                            <div class="metric-card" style="border-left: 4px solid var(--velocity-${Math.round(
                              metrics.velocity
                            )}-color);">
                                <div class="metric-label">Avg Velocity</div>
                                <div class="metric-value">${metrics.velocity.toFixed(
                                  1
                                )}</div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-label">Avg Magnitude</div>
                                <div class="metric-value">${metrics.magnitude.toFixed(
                                  1
                                )}</div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-label">Total Risks</div>
                                <div class="metric-value">${metrics.count}</div>
                            </div>
                        </div>
                        
                        <h3 class="font-medium mb-2">Risks (${
                          entityRisks.length
                        })</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full bg-white dark:bg-gray-800 rounded-lg overflow-hidden">
                                <thead class="bg-gray-100 dark:bg-gray-700">
                                    <tr>
                                        <th class="px-4 py-2 text-left">ID</th>
                                        <th class="px-4 py-2 text-left">Title</th>
                                        <th class="px-4 py-2 text-left">Level</th>
                                        <th class="px-4 py-2 text-left">Priority</th>
                                        <th class="px-4 py-2 text-left">Velocity</th>
                                        <th class="px-4 py-2 text-left">Magnitude</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${entityRisks
                                      .map((risk) => {
                                        const timeData =
                                          risk.timeData[timeIndex];
                                        return `
                                            <tr class="border-t border-gray-200 dark:border-gray-700">
                                                <td class="px-4 py-2">${
                                                  risk.id
                                                }</td>
                                                <td class="px-4 py-2">${
                                                  risk.title
                                                }</td>
                                                <td class="px-4 py-2">${
                                                  risk.level
                                                }</td>
                                                <td class="px-4 py-2">
                                                    <div class="flex items-center">
                                                        <div class="w-3 h-3 rounded-full mr-2" style="background-color: ${getPriorityColor(
                                                          timeData.priority
                                                        )};"></div>
                                                        P${Math.round(
                                                          timeData.priority
                                                        )}
                                                    </div>
                                                </td>
                                                <td class="px-4 py-2">V${Math.round(
                                                  timeData.velocity
                                                )}</td>
                                                <td class="px-4 py-2">${timeData.magnitude.toFixed(
                                                  1
                                                )}</td>
                                            </tr>
                                        `;
                                      })
                                      .join("")}
                                </tbody>
                            </table>
                        </div>
                    `
                    }
                </div>
            `;

        document.body.appendChild(popup);

        // Close popup when clicking the close button
        const closeButton = popup.querySelector(".close-popup");
        closeButton.addEventListener("click", () => {
          popup.remove();
          backdrop.remove();
        });

        // Close popup when clicking backdrop
        backdrop.addEventListener("click", () => {
          popup.remove();
          backdrop.remove();
        });

        // Close popup when pressing Escape key
        document.addEventListener("keydown", function closeOnEscape(e) {
          if (e.key === "Escape") {
            popup.remove();
            backdrop.remove();
            document.removeEventListener("keydown", closeOnEscape);
          }
        });
      }

      // Track selected entities for drill-down
      let selectedDivision = null;
      let selectedDepartment = null;

      // Helper function to set org level with proper slider position
      function setOrgLevel(level) {
        // Set slider position
        orgSlider.value = level;

        // Update the aquarium
        updateAquarium();
      }

      // Update aquarium based on selected time and organization level
      function updateAquarium() {
        if (!AppState.current?.risks) {
          const statusEl = document.getElementById("data-status");
          if (statusEl) {
            statusEl.textContent = `Loading week ${
              AppState.current?.timeIndex ?? 4
            }...`;
          }
          debugLog("updateAquarium: Waiting for data", AppState.current);
          return;
        }

        const timeIndex = parseInt(timeSlider?.value || 4);
        const orgLevel = parseInt(orgSlider?.value || 0);

        // Validate data exists
        if (!timeIndexedData[timeIndex]?.risks) {
          console.warn(
            `updateAquarium: Waiting for timeIndex ${timeIndex} data...`
          );
          return; // Will retry when data loads
        }

        // Clear existing bubbles
        document
          .querySelectorAll(".risk-bubble")
          .forEach((bubble) => bubble.remove());

        // Use Excel-loaded data (timeIndexedData) instead of generateRisksData()
        const currentData = timeIndexedData[timeIndex] || {};

        const { risks, orgStructure } = AppState.current;
        if (!risks || !orgStructure) {
          console.debug(
            "updateAquarium: Waiting for data...",
            AppState.current
          );
          return;
        }

        // Clear existing risk bubbles
        document
          .querySelectorAll(".risk-bubble")
          .forEach((bubble) => bubble.remove());

        // Update labels
        switch (timeIndex) {
          case 0:
            timeLabel.textContent = "4 weeks ago";
            break;
          case 1:
            timeLabel.textContent = "3 weeks ago";
            break;
          case 2:
            timeLabel.textContent = "2 weeks ago";
            break;
          case 3:
            timeLabel.textContent = "1 week ago";
            break;
          case 4:
            timeLabel.textContent = "Current";
            break;
        }

        switch (orgLevel) {
          case 0:
            orgLevelIndicator.textContent = "Organization";
            selectedDivision = null;
            selectedDepartment = null;
            break;
          case 1:
            orgLevelIndicator.textContent = "Divisions";
            selectedDepartment = null;
            break;
          case 2:
            orgLevelIndicator.textContent = selectedDivision
              ? `Departments in ${selectedDivision}`
              : "All Departments";
            break;
          case 3:
            orgLevelIndicator.textContent = selectedDepartment
              ? `Business Units in ${selectedDepartment}`
              : "All Business Units";
            break;
          case 4:
            orgLevelIndicator.textContent = "Individual Risks";
            break;
        }

        if (orgLevel === 0) {
          if (!AppState.current?.orgStructure) {
            console.warn("updateAquarium: No orgStructure available");
            return;
          }

          // Organization level - show a single bubble for the whole organization
          const orgMetrics = calculateAggregatedRiskMetrics(
            "organization",
            AppState.current.orgStructure.organization,
            null,
            timeIndex
          );

          const orgBubble = createEntityBubble(
            "organization",
            AppState.current.orgStructure.organization,
            null,
            null,
            orgMetrics,
            timeIndex
          );

          aquarium.appendChild(orgBubble);
        } else if (orgLevel === 1) {
          // Division level - show one bubble per division
          AppState.current.orgStructure.divisions.forEach((division) => {
            const divisionMetrics = calculateAggregatedRiskMetrics(
              "division",
              division.name,
              null,
              timeIndex
            );
            const divisionBubble = createEntityBubble(
              "division",
              division.name,
              null,
              null,
              divisionMetrics,
              timeIndex
            );
            aquarium.appendChild(divisionBubble);
          });
        } else if (orgLevel === 2) {
          // Department level
          AppState.current.orgStructure.divisions.forEach((division) => {
            // If a division is selected, only show departments from that division
            if (selectedDivision && division.name !== selectedDivision) return;

            division.departments.forEach((department) => {
              const departmentMetrics = calculateAggregatedRiskMetrics(
                "department",
                department.name,
                division.name,
                timeIndex
              );
              const departmentBubble = createEntityBubble(
                "department",
                department.name,
                division.name,
                null,
                departmentMetrics,
                timeIndex
              );
              aquarium.appendChild(departmentBubble);
            });
          });
        } else if (orgLevel === 3) {
          // Business Unit level
          AppState.current.orgStructure.divisions.forEach((division) => {
            // If a division is selected, only consider that division
            if (selectedDivision && division.name !== selectedDivision) return;

            division.departments.forEach((department) => {
              // If a department is selected, only consider that department
              if (selectedDepartment && department.name !== selectedDepartment)
                return;

              department.businessUnits.forEach((bu) => {
                const buMetrics = calculateAggregatedRiskMetrics(
                  "businessUnit",
                  bu,
                  department.name,
                  timeIndex
                );
                const buBubble = createEntityBubble(
                  "businessUnit",
                  bu,
                  department.name,
                  division.name,
                  buMetrics,
                  timeIndex
                );
                aquarium.appendChild(buBubble);
              });
            });
          });
        } else if (orgLevel === 4) {
          // Individual risks level - show all individual risks
          const risksToShow = [];

          if (selectedDepartment && selectedDivision) {
            // If department is selected, show risks for that department and its BUs
            AppState.current.risks.forEach((risk) => {
              if (
                (risk.level === "department" &&
                  risk.entity === selectedDepartment &&
                  risk.parentEntity === selectedDivision) ||
                (risk.level === "businessUnit" &&
                  risk.parentEntity === selectedDepartment &&
                  risk.grandparentEntity === selectedDivision)
              ) {
                risksToShow.push(risk);
              }
            });
          } else if (selectedDivision) {
            // If only division is selected, show risks for that division and its departments/BUs
            AppState.current.risks.forEach((risk) => {
              if (
                (risk.level === "division" &&
                  risk.entity === selectedDivision) ||
                (risk.level === "department" &&
                  risk.parentEntity === selectedDivision) ||
                (risk.level === "businessUnit" &&
                  risk.grandparentEntity === selectedDivision)
              ) {
                risksToShow.push(risk);
              }
            });
          } else {
            // Otherwise show all risks
            risksToShow.push(...AppState.current.risks);
          }

          // Create and add risk bubbles
          risksToShow.forEach((risk) => {
            const riskBubble = createRiskBubbleElement(risk, timeIndex);
            aquarium.appendChild(riskBubble);
          });
        }
      }

      // Initialize bubbles
      createBubbles();

      // Update aquarium on slider change
      timeSlider.addEventListener("input", updateAquarium);
      orgSlider.addEventListener("input", updateAquarium);

      // Initial update - start with Organization view
      setOrgLevel(0);

      // Handle window resize
      window.addEventListener("resize", () => {
        updateAquarium();
        createBubbles();
      });
    </script>
  </body>
</html>
